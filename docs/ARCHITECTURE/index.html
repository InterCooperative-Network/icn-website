<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="A substrate daemon for the cooperative internet. DIDs, trust graphs, mutual credit, CCL contracts, and democratic governance â€” all in one P2P coordination layer."><meta name="theme-color" content="#06090f"><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://intercooperative.network/#organization","name":"InterCooperative Network","url":"https://intercooperative.network","logo":"https://intercooperative.network/favicon.svg","sameAs":["https://github.com/InterCooperative-Network"]},{"@type":"WebSite","@id":"https://intercooperative.network/#website","url":"https://intercooperative.network","name":"InterCooperative Network","description":"A substrate daemon for the cooperative internet.","publisher":{"@id":"https://intercooperative.network/#organization"}}]}</script><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Outfit:wght@600;700;800&display=swap" rel="stylesheet"><title>ICN Architecture | InterCooperative Network</title><script>
    // Prevent theme flash
    const theme = (() => {
      if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {
        return localStorage.getItem('theme');
      }
      return 'dark';
    })();
    if (theme === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
  </script><link rel="stylesheet" href="/_astro/about.EmGYcvGr.css">
<style>.breadcrumb[data-astro-cid-uadgga6g]{display:flex;align-items:center;gap:var(--space-xs);font-size:.8125rem;margin-bottom:var(--space-lg);flex-wrap:wrap}.breadcrumb[data-astro-cid-uadgga6g] a[data-astro-cid-uadgga6g]{color:var(--accent-teal)}.breadcrumb-sep[data-astro-cid-uadgga6g]{color:var(--text-muted)}.breadcrumb-dir[data-astro-cid-uadgga6g]{color:var(--text-secondary);text-transform:capitalize}.breadcrumb-current[data-astro-cid-uadgga6g]{color:var(--text-primary);text-transform:capitalize}.doc-meta[data-astro-cid-uadgga6g]{margin-bottom:var(--space-xl);padding-bottom:var(--space-md);border-bottom:1px solid var(--border-subtle)}.source-link[data-astro-cid-uadgga6g]{font-size:.8125rem;color:var(--text-muted)}.source-link[data-astro-cid-uadgga6g]:hover{color:var(--accent-teal)}.doc-footer[data-astro-cid-uadgga6g]{margin-top:var(--space-3xl);padding-top:var(--space-xl);border-top:1px solid var(--border-subtle)}
</style></head> <body> <!-- Navigation --> <nav class="nav" id="main-nav"> <div class="nav-inner"> <a href="/" class="nav-logo"> <svg class="nav-logo-svg" width="28" height="28" viewBox="0 0 128 128" fill="none"> <rect width="128" height="128" rx="28" fill="url(#nav-bg)"></rect> <line x1="64" y1="30" x2="34" y2="82" stroke="url(#nav-teal)" stroke-width="4" stroke-linecap="round" opacity="0.6"></line> <line x1="64" y1="30" x2="94" y2="82" stroke="url(#nav-teal)" stroke-width="4" stroke-linecap="round" opacity="0.6"></line> <line x1="34" y1="82" x2="94" y2="82" stroke="url(#nav-teal)" stroke-width="4" stroke-linecap="round" opacity="0.6"></line> <circle cx="64" cy="30" r="11" fill="url(#nav-teal)"></circle> <circle cx="34" cy="82" r="11" fill="url(#nav-teal)"></circle> <circle cx="94" cy="82" r="11" fill="url(#nav-teal)"></circle> <circle cx="64" cy="64" r="4" fill="url(#nav-teal)" opacity="0.8"></circle> <defs> <linearGradient id="nav-bg" x1="0" y1="0" x2="1" y2="1"><stop stop-color="#0f2027"></stop><stop offset="1" stop-color="#0a1628"></stop></linearGradient> <linearGradient id="nav-teal" x1="0" y1="0" x2="1" y2="1"><stop stop-color="#2dd4bf"></stop><stop offset="1" stop-color="#38bdf8"></stop></linearGradient> </defs> </svg> <span>ICN</span> </a> <ul class="nav-links" id="nav-links"> <li><a href="/about">About</a></li> <li><a href="/docs" class="active">Docs</a></li> <li><a href="/architecture">Architecture</a></li> <li><a href="/roadmap">Roadmap</a></li> <li><a href="/community">Community</a></li> <li><a href="/blog">Blog</a></li> </ul> <div class="nav-cta"> <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme" data-astro-cid-x3pjskd3> <svg class="sun-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-x3pjskd3><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" data-astro-cid-x3pjskd3></path></svg> <svg class="moon-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-x3pjskd3><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" data-astro-cid-x3pjskd3></path></svg> </button>  <script>
  const theme = (() => {
    if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {
      return localStorage.getItem('theme');
    }
    return 'dark';
  })();

  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
  } else {
    document.documentElement.removeAttribute('data-theme');
  }

  window.localStorage.setItem('theme', theme);

  const handleToggleClick = () => {
    const element = document.documentElement;
    if (element.getAttribute('data-theme') === 'light') {
      element.removeAttribute('data-theme');
      localStorage.setItem('theme', 'dark');
    } else {
      element.setAttribute('data-theme', 'light');
      localStorage.setItem('theme', 'light');
    }
  };

  document.getElementById('theme-toggle')?.addEventListener('click', handleToggleClick);
</script> <a href="https://github.com/InterCooperative-Network/icn" target="_blank" rel="noopener" class="nav-github" aria-label="GitHub"> <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"></path></svg> </a> <a href="/docs/GETTING_STARTED" class="btn btn-primary btn-sm">Get Started</a> </div> <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu"> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h18M3 6h18M3 18h18"></path></svg> </button> </div> </nav> <!-- Main Content --> <main>  <section class="section" style="padding-top: calc(64px + var(--space-2xl));" data-astro-cid-uadgga6g> <div class="container-narrow" data-astro-cid-uadgga6g> <!-- Breadcrumb --> <nav class="breadcrumb" data-astro-cid-uadgga6g> <a href="/docs" data-astro-cid-uadgga6g>Docs</a>  <span class="breadcrumb-sep" data-astro-cid-uadgga6g>/</span> <span class="breadcrumb-current" data-astro-cid-uadgga6g>ARCHITECTURE</span> </nav> <!-- Source link --> <div class="doc-meta" data-astro-cid-uadgga6g> <a href="https://github.com/InterCooperative-Network/icn/blob/main/ARCHITECTURE.md" target="_blank" class="source-link" data-astro-cid-uadgga6g>
View source on GitHub â†’
</a> </div> <!-- Rendered markdown --> <article class="prose" data-astro-cid-uadgga6g><h1>ICN Architecture</h1>
<p><strong>Status:</strong> Living Document
<strong>Version:</strong> 0.1.0
<strong>Last Updated:</strong> 2025-12-10</p>
<p><strong>Abstract:</strong></p>
<p>ICNd is a <strong>decentralized coordination substrate</strong> for cooperative organizationsâ€”a Rust P2P daemon that enables cooperatives, communities, and federations to coordinate identity, trust, governance, mutual-credit economics, contracts, replication, and compute without central servers or blockchain-style global consensus.</p>
<p>This document captures architectural decisions, design tradeoffs, and the reasoning behind ICNd&#39;s implementation.</p>
<hr>
<h2>Design Principles</h2>
<p>ICN is built on five foundational principles that guide all architectural decisions:</p>
<ul>
<li><strong>Local-first</strong>: Nodes operate independently and reconcile via gossip, maximizing autonomy and resilience</li>
<li><strong>Trust-native</strong>: Security and coordination derive from social trust edges, not global consensus or proof-of-work</li>
<li><strong>Deterministic compute</strong>: Same inputs â†’ same outputs â†’ same ledger state on all nodes</li>
<li><strong>Capability-based security</strong>: Contracts cannot do anything they are not explicitly permitted to do</li>
<li><strong>Human-governed</strong>: Cooperative governance makes policy changes democratic and auditable</li>
</ul>
<p>These principles ensure ICN remains decentralized, resilient, and aligned with cooperative values.</p>
<hr>
<h2>Table of Contents</h2>
<ol>
<li><a href="#1-identity--key-management">Identity & Key Management</a><ul>
<li>1.5 <a href="#15-sdis-identity-extensions-experimental">SDIS Identity Extensions</a><ul>
<li>1.5.9 <a href="#159-zero-knowledge-proofs-phase-s4">Zero-Knowledge Proofs</a></li>
<li>1.5.10 <a href="#1510-credential-presentation-phase-s5">Credential Presentation</a></li>
<li>1.5.11 <a href="#1511-sdis-governance-phase-s6">SDIS Governance</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-trust-graph-model">Trust Graph Model</a></li>
<li><a href="#3-network-transport">Network Transport</a></li>
<li><a href="#4-ledger-design">Ledger Design</a></li>
<li><a href="#5-contract-execution-ccl">Contract Execution (CCL)</a></li>
<li><a href="#6-gossip--synchronization">Gossip & Synchronization</a></li>
<li><a href="#7-data-storage">Data Storage</a></li>
<li><a href="#8-security-model">Security Model</a></li>
<li><a href="#9-performance--scalability">Performance & Scalability</a></li>
<li><a href="#10-operational-considerations">Operational Considerations</a></li>
<li><a href="#11-distributed-compute-layer">Distributed Compute Layer</a><ul>
<li>11.1 <a href="#111-core-architecture">Core Architecture</a></li>
<li>11.2 <a href="#112-scheduler-evolution-phase-16a-e">Scheduler Evolution</a></li>
<li>11.3 <a href="#113-cooperative-scheduling-policies-phase-16e">Cooperative Scheduling Policies</a></li>
<li>11.4 <a href="#114-example-policies">Example Policies</a></li>
<li>11.5 <a href="#115-api-surface">API Surface</a></li>
<li>11.6 <a href="#116-future-enhancements">Future Enhancements</a></li>
<li>11.7 <a href="#117-decision-rationale">Decision Rationale</a></li>
<li>11.8 <a href="#118-integration-summary">Integration Summary</a></li>
</ul>
</li>
<li><a href="#12-known-limitations--future-work">Known Limitations & Future Work</a></li>
<li><a href="#13-node-morphogenesis">Node Morphogenesis</a><ul>
<li>13.1 <a href="#131-design-philosophy">Design Philosophy</a></li>
<li>13.2 <a href="#132-principal-vs-node-identity">Principal vs Node Identity</a></li>
<li>13.3 <a href="#133-servicerole--capabilities">ServiceRole & Capabilities</a></li>
<li>13.4 <a href="#134-nodeprofile-structure">NodeProfile Structure</a></li>
<li>13.5 <a href="#135-node-lifecycle-nodestage">Node Lifecycle (NodeStage)</a></li>
<li>13.6 <a href="#136-role-inference">Role Inference</a></li>
<li>13.7 <a href="#137-multi-device--shared-devices">Multi-Device & Shared Devices</a></li>
<li>13.8 <a href="#138-integration-with-existing-systems">Integration with Existing Systems</a></li>
</ul>
</li>
<li><a href="#14-federation-layer">Federation Layer</a><ul>
<li>14.1 <a href="#141-overview">Overview</a></li>
<li>14.2 <a href="#142-core-types">Core Types</a></li>
<li>14.3 <a href="#143-trust-bridging-f2">Trust Bridging</a></li>
<li>14.4 <a href="#144-credit-settlement-f3">Credit Settlement</a></li>
<li>14.5 <a href="#145-federated-did-resolution-f5">Federated DID Resolution</a></li>
<li>14.6 <a href="#146-gossip-topics">Gossip Topics</a></li>
<li>14.7 <a href="#147-architecture">Architecture</a></li>
<li>14.8 <a href="#148-metrics">Metrics</a></li>
<li>14.9 <a href="#149-implementation-status">Implementation Status</a></li>
</ul>
</li>
</ol>
<hr>
<h2>How to Read This Document</h2>
<p><strong>Sections 1â€“4</strong> define ICN&#39;s identity, trust, transport, and ledger primitivesâ€”the foundational substrate.</p>
<p><strong>Sections 5â€“8</strong> define contract execution, gossip synchronization, persistent storage, and the security model.</p>
<p><strong>Sections 9â€“10</strong> outline performance considerations and operational best practices.</p>
<p><strong>Section 11</strong> integrates all prior components into the distributed compute system, demonstrating how the substrate enables cooperative task execution.</p>
<hr>
<h2>What ICN Does: The Whole System</h2>
<p>Before diving into architectural boundaries, it&#39;s essential to understand what ICN provides as a complete system.</p>
<h3>Core Subsystems</h3>
<p>ICN coordinates several interrelated capabilities:</p>
<ol>
<li><p><strong>Identity</strong>: Decentralized identifiers (DIDs) with Ed25519 signatures, X25519 encryption, Age-encrypted keystore. Establishes &quot;who said this&quot; and &quot;who can do what.&quot;</p>
</li>
<li><p><strong>Network Transport</strong>: QUIC/TLS secure sessions, mDNS discovery, NAT traversal, message authentication. Moves signed messages between nodes with DID-TLS binding.</p>
</li>
<li><p><strong>Replication &amp; Gossip</strong>: Eventual consistency through push/pull protocols, anti-entropy with Bloom filters, causal ordering via vector clocks, topic-based dissemination. Ensures shared state converges across the network.</p>
</li>
<li><p><strong>Trust Computation</strong>: Web-of-participation scoring, transitive trust propagation, multi-graph support for different trust contexts. This is semantic and community-definedâ€”trust scores inform access control and resource allocation.</p>
</li>
<li><p><strong>Ledger &amp; Economics</strong>: Mutual-credit accounting with double-entry bookkeeping, Merkle-DAG journal, credit limits and safety rails, fork detection and resolution. Enables value exchange without central currency.</p>
</li>
<li><p><strong>Contracts &amp; Capabilities</strong>: CCL (Cooperative Contract Language) interpreter with fuel metering, capability-based security model defining who can invoke what actions under which constraints.</p>
</li>
<li><p><strong>Governance Primitives</strong>: Democratic policy-making through proposals and voting, domain-specific rules, membership criteria. Determines <em>what constraints should be enforced</em>.</p>
</li>
<li><p><strong>Distributed Compute</strong>: Trust-gated task execution, intelligent scheduling based on trust/resources/economics, result verification. Enables cooperative task distribution.</p>
</li>
<li><p><strong>Runtime &amp; Supervision</strong>: Actor-based services using Tokio, lifecycle management, orchestration of startup/shutdown, inter-actor communication.</p>
</li>
</ol>
<h3>Typical Flow</h3>
<p>Here&#39;s how these subsystems work together:</p>
<ol>
<li>A node receives a <strong>signed message</strong> over QUIC/TLS transport</li>
<li>The <strong>kernel validates invariants</strong>: authentication, replay protection, rate limits, capability gates, credit gates</li>
<li><strong>State replication</strong> through gossip moves validated events across the network</li>
<li><strong>Policy subsystems</strong> (trust, governance, ledger) compute semantic meanings from events</li>
<li>Those meanings are expressed as <strong>constraints</strong> (rate limits, credit ceilings, capability grants)</li>
<li>The <strong>kernel enforces those constraints</strong> on subsequent actions without understanding their semantic origin</li>
</ol>
<h3>What Makes ICN Different</h3>
<p>Unlike blockchains (global consensus, trustless assumptions) or traditional federation servers (central authority), ICN:</p>
<ul>
<li>Operates <strong>local-first</strong>: Nodes work independently, sync via gossip</li>
<li>Is <strong>trust-native</strong>: Security derives from social relationships, not proof-of-work</li>
<li>Provides <strong>deterministic compute</strong>: Same inputs â†’ same outputs â†’ same ledger state</li>
<li>Uses <strong>capability-based security</strong>: Explicit, revocable grants</li>
<li>Enables <strong>human governance</strong>: Democratic, auditable policy changes</li>
</ul>
<hr>
<h2>The Constraint Engine Model</h2>
<p>Now that we understand what ICN does as a whole system, we can examine its <strong>architectural invariant</strong>: the separation between policy decisions and enforcement mechanisms.</p>
<blockquote>
<p><strong>ICN is a constraint engine: apps translate meaning into constraints; the kernel enforces constraints without understanding meaning.</strong></p>
</blockquote>
<p>ICN implements a <strong>constraint enforcement architecture</strong> where applications and governance systems (Policy Oracles) translate domain semantics (trust relationships, governance rules, membership criteria) into generic constraints that the kernel enforces blindly.</p>
<p><strong>What the kernel is:</strong> The kernel defines and enforces bounded resource and integrity mechanisms (rate limiting, replay protection, signature verification, capability and credit gates); it does not compute or interpret domain semantics.</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CONSTRAINT ENFORCEMENT (Kernel)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  Transport  â”‚  Replay  â”‚  Rate     â”‚  Capability â”‚  Credit    â”‚ â”‚â”‚
â”‚  â”‚   Auth      â”‚  Guard   â”‚  Limiter  â”‚   Gate      â”‚  Gate      â”‚ â”‚â”‚
â”‚  â”‚  (verify)   â”‚ (reject) â”‚  (apply)  â”‚  (enforce)  â”‚  (enforce) â”‚ â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                      â”‚
â”‚   Kernel enforces ConstraintSet values. Kernel does NOT decide them. â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²              â–²           â–²            â–²           â–²
         â”‚              â”‚           â”‚            â”‚           â”‚
    ConstraintSet {                              // Illustrative example
      rate_limit: 20/s,      // â† value from Policy Oracle
      credit_ceiling: 1000,  // â† value from Policy Oracle
      capabilities: [...]    // â† value from Policy Oracle
    }
         â”‚              â”‚           â”‚            â”‚           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      POLICY ORACLES (Apps)                           â”‚
â”‚                                                                      â”‚
â”‚   Apps/Governance DECIDE constraint values.                          â”‚
â”‚   Kernel ENFORCES them without knowing why.                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  Trust   â”‚  â”‚  Ledger  â”‚  â”‚Governanceâ”‚  â”‚Membershipâ”‚            â”‚
â”‚  â”‚  Oracle  â”‚  â”‚  Oracle  â”‚  â”‚  Oracle  â”‚  â”‚  Oracle  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>This diagram illustrates the enforcement boundary <em>inside</em> the broader substrate described above. The kernel sits at the center of ICN&#39;s data flow, validating and enforcing constraints that Policy Oracles compute from domain semantics.</p>
<h3>Key Distinction: Mechanism vs. Policy</h3>
<p>The constraint engine model distinguishes between <strong>enforcement mechanisms</strong> (kernel) and <strong>constraint values</strong> (apps/governance):</p>
<table>
<thead>
<tr>
<th></th>
<th>Kernel (Hard)</th>
<th>Apps/Governance (Meta)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Rate limiting</strong></td>
<td>Mechanism exists</td>
<td>Values decided (20/s vs 100/s)</td>
</tr>
<tr>
<td><strong>Credit gating</strong></td>
<td>Mechanism exists</td>
<td>Ceiling decided (1000 vs 5000)</td>
</tr>
<tr>
<td><strong>Capability gating</strong></td>
<td>Mechanism exists</td>
<td>Grants decided</td>
</tr>
<tr>
<td><strong>Replay guard</strong></td>
<td>Mechanism exists</td>
<td>Typically fixed</td>
</tr>
<tr>
<td><strong>Transport auth</strong></td>
<td>Mechanism exists</td>
<td>Typically fixed</td>
</tr>
</tbody></table>
<p><strong>Critical Property:</strong></p>
<ul>
<li>Governance can change <strong>what</strong> the rate limit is (e.g., from 20/s to 100/s)</li>
<li>Governance <strong>cannot</strong> remove <strong>that</strong> rate limiting exists (enforcement mechanism is fixed)</li>
</ul>
<p>This separation ensures the kernel remains predictable and auditable while allowing cooperative governance to adapt policies to changing needs.</p>
<h3>Kernel Guarantees</h3>
<p>The kernel permanently guarantees these enforcement mechanisms. Governance may adjust their parameters, but cannot remove them:</p>
<ul>
<li><strong>Signature verification</strong> â€” every message cryptographically authenticated</li>
<li><strong>Replay protection</strong> â€” sequence tracking prevents duplicate processing</li>
<li><strong>Capability gating</strong> â€” actions require explicit, revocable grants</li>
<li><strong>Credit gating</strong> â€” transactions bounded by credit ceilings</li>
<li><strong>Rate limiting</strong> â€” per-actor throughput bounds enforced</li>
<li><strong>Deterministic execution</strong> â€” same inputs always produce same outputs</li>
</ul>
<p>These guarantees form ICN&#39;s security spine. A governance proposal can change a rate limit from 20/s to 100/s, but no proposal can disable rate limiting itself.</p>
<blockquote>
<p><strong>Boundary clarification:</strong> This boundary is conceptual, not physical. Many crates contain both kernel and oracle surfaces. The separation is defined by <strong>data flow</strong> (who produces <code>ConstraintSet</code> values vs. who enforces them), not by file or crate location. Do not reorganize crates to &quot;match the diagram.&quot;</p>
</blockquote>
<blockquote>
<p><strong>Terminology:</strong> A <em>Policy Oracle</em> is any component that computes <code>ConstraintSet</code> values from domain semantics â€” not necessarily an &quot;external app.&quot; Trust scoring, governance voting, and ledger policy are all Policy Oracles even though they live in the same process. The <code>ConstraintSet</code> they produce flows into the kernel&#39;s enforcement points: rate limiter, capability gate, credit gate, and replay guard.</p>
</blockquote>
<h3>Functional Component Map (Not a Sequential Stack)</h3>
<p>While the constraint engine model describes the <strong>conceptual architecture</strong>, the actual implementation organizes components into these functional areas. These are not layered in the OSI senseâ€”Policy Oracles and Kernel can interact with the same substrate services:</p>
<ul>
<li><strong>Identity (Â§1)</strong>: DID, Ed25519, keystore â€” substrate service</li>
<li><strong>Trust Graph (Â§2)</strong>: Web-of-participation scores â†’ <strong>Policy Oracle</strong></li>
<li><strong>Transport (Â§3)</strong>: QUIC/TLS, mDNS, NAT traversal â†’ <strong>Kernel</strong> substrate service</li>
<li><strong>Ledger (Â§4)</strong>: Mutual credit, double-entry â†’ <strong>Policy Oracle</strong></li>
<li><strong>Contracts (Â§5)</strong>: CCL interpreter, capabilities â†’ <strong>Policy Oracle</strong></li>
<li><strong>Gossip (Â§6)</strong>: Causal sync, anti-entropy â†’ <strong>Kernel</strong> substrate service</li>
<li><strong>Storage (Â§7)</strong>: Sled, persistent state â€” substrate service</li>
<li><strong>Security (Â§8)</strong>: Production hardening</li>
<li><strong>Distributed Compute (Â§11)</strong>: Trust-gated task execution â†’ <strong>Policy Oracle</strong></li>
</ul>
<p><strong>Boundary rule:</strong> Anything that outputs constraint values is a Policy Oracle; anything that validates or enforces constraints is kernel (even if they live near each other in code). Many subsystems have both mechanism and policy surfacesâ€”the boundary is determined by the data flow, not the crate structure.</p>
<p><strong>Note on terminology:</strong> You&#39;ll see references to &quot;layers&quot; throughout this document in a descriptive sense (e.g., &quot;transport layer security&quot;, &quot;network layer&quot;). This is legitimate technical terminology. What ICN is <strong>not</strong> is an OSI-like strictly layered stack where higher layers can only access lower layers through defined interfaces. Instead, ICN uses the constraint engine model where policy oracles (apps) translate domain semantics into constraints that the kernel enforces.</p>
<p><strong>Why the old layered diagram existed:</strong> Earlier documentation used a traditional layered stack diagram for pedagogical purposesâ€”it was easier to explain &quot;transport â†’ identity â†’ trust â†’ gossip â†’ ledger&quot; as a sequential stack. However, this mental model was imprecise and has been replaced by the constraint engine/lattice model, which more accurately captures how ICN actually works.</p>
<hr>
<h2>Kernel/App Separation</h2>
<p><strong>Goal:</strong> Remove direct domain imports from kernel crates (<code>icn-core</code>, <code>icn-net</code>, <code>icn-gossip</code>) by routing all domain knowledge through boundary traits in <code>icn-kernel-api</code>, implemented by app-layer adapters.
Canonical runtime app location is <code>icn/apps/*</code>; legacy top-level <code>apps/*</code> remains during migration.</p>
<h3>Definition</h3>
<ul>
<li><p><strong>Kernel</strong> (pure enforcement):</p>
<ul>
<li>Networking transport, gossip plumbing, actor runtime, constraint enforcement, message validation.</li>
<li>Knows: DIDs, cert bindings, timestamps, constraints, capabilities, resource budgets.</li>
<li>Does <strong>not</strong> know: trust graphs, governance rules, ledger semantics, compute placement rules, community/entity domain objects.</li>
</ul>
</li>
<li><p><strong>App / Policy Oracles</strong> (meaning + policy):</p>
<ul>
<li>Trust graph, governance, ledger, CCL semantics, compute policy, federation/domain mappings, gateways/RPC.</li>
<li>Implements boundary traits and converts domain state into kernel constraints.</li>
</ul>
</li>
</ul>
<h3>Core flow</h3>
<ul>
<li><code>transport_auth</code> authenticates a connection and yields a DID.</li>
<li>DID becomes the sole identity handle used by the kernel.</li>
<li>Kernel asks <code>PolicyOracle</code> for constraints and authorization decisions.</li>
<li>Kernel enforces those constraints without knowing why they exist.</li>
</ul>
<pre><code class="language-mermaid">flowchart LR
  A[&quot;transport_auth (TLS/QUIC)&quot;] --&gt; B[&quot;DID resolution (IdentityBundle)&quot;]
  B --&gt; C[PolicyOracle]
  C --&gt; D[ConstraintSet]
  D --&gt; E[&quot;Kernel enforcement (icn-core/icn-net/icn-gossip)&quot;]
  C &lt;--&gt;|adapters| F[&quot;App layer (icn/apps/* canonical, apps/* transitional)&quot;]
</code></pre>
<h3>Pass 7 invariants as kernel-level contracts</h3>
<p>These invariants must remain true regardless of app semantics:</p>
<ol>
<li><p><strong>Identity â†” Transport â†” Policy</strong></p>
<ul>
<li>Transport auth yields a DID bound to the certificate identity.</li>
<li>All policy decisions are made against that DID.</li>
<li>Kernel rejects any mismatch between transport identity and claimed identity.</li>
</ul>
</li>
<li><p><strong>Misbehavior â†” Trust â†” Rate limits</strong></p>
<ul>
<li>Kernel records violations + evidence; app converts to reputation/trust updates.</li>
<li>Enforcement is via constraints (quarantine/ban/rate limits), not domain interpretation.</li>
</ul>
</li>
<li><p><strong>Time validation and replay protection</strong></p>
<ul>
<li>Kernel validates timestamps via <code>ClockSync</code> windowing.</li>
<li>Replay rejection must preserve liveness during drift events.</li>
</ul>
</li>
<li><p><strong>Store â†” Snapshot â†” Encoding integrity</strong></p>
<ul>
<li>Kernel requires versioned, canonical encodings for state transitions/snapshots.</li>
<li>Snapshot boundaries align with transactional store writes.</li>
<li>Unknown versions must fail fast with a documented upgrade path.</li>
</ul>
</li>
<li><p><strong>Privacy â†” Observability budget</strong></p>
<ul>
<li>Metrics/logging must not leak topic membership or sensitive identifiers.</li>
<li>Observability is an explicit budget with redlines.</li>
</ul>
</li>
<li><p><strong>ZKP â†” Revocation â†” Governance</strong></p>
<ul>
<li>Kernel verifies proofs deterministically and versioned.</li>
<li>Issuer roots/revocation state is app-owned but enforced through kernel checks.</li>
</ul>
</li>
<li><p><strong>PQ dual-stack transition</strong></p>
<ul>
<li>During migration, verification must accept old+new per negotiated capability.</li>
<li>Deprecation is governance-controlled, policy-enforced.</li>
</ul>
</li>
</ol>
<h3>Encoding and versioning policy</h3>
<ul>
<li>Versioned encodings must be canonical and stable across releases.</li>
<li>Snapshot and state payloads must use versioned encodings with explicit negotiation rules.</li>
<li>Unknown versions fail fast with a documented upgrade path (no silent fallback).</li>
</ul>
<h3>Migration principle</h3>
<p><strong>Kernel compiles with zero direct imports of domain crates.</strong>
All domain dependency crosses the boundary via <code>icn-kernel-api</code> traits.</p>
<h3>Boundary map (template)</h3>
<table>
<thead>
<tr>
<th>Kernel crate/file</th>
<th>Current forbidden import</th>
<th>Why itâ€™s a violation</th>
<th>Replacement boundary trait</th>
<th>Adapter implementation</th>
</tr>
</thead>
<tbody><tr>
<td><code>icn-core/src/policy.rs</code></td>
<td><code>icn_trust::*</code></td>
<td>kernel reading trust semantics</td>
<td><code>PolicyOracle</code>, <code>PolicyRequest</code>, <code>ConstraintSet</code></td>
<td><code>apps/trust::oracle</code></td>
</tr>
<tr>
<td><code>icn-core/src/identity.rs</code></td>
<td><code>icn_trust::*</code></td>
<td>identity actor doing trust logic</td>
<td><code>PolicyOracle</code> call with DID</td>
<td><code>apps/trust::oracle</code></td>
</tr>
<tr>
<td><code>icn-core/src/supervisor/init_trust.rs</code></td>
<td><code>icn_trust::*</code></td>
<td>kernel creating trust graph</td>
<td><code>KernelInitHooks</code> or injected oracle</td>
<td><code>apps/trust::init</code></td>
</tr>
<tr>
<td><code>icn-net/src/tls.rs</code></td>
<td><code>icn_trust::*</code></td>
<td>TLS verifier using trust graph</td>
<td><code>PolicyOracle</code> evaluate(DID, TransportContext)</td>
<td><code>apps/trust::oracle</code></td>
</tr>
<tr>
<td><code>icn-gossip/src/gossip.rs</code></td>
<td>legacy <code>TrustClass</code></td>
<td>gossip depends on trust semantics</td>
<td><code>ConstraintSet</code> (rate/topic gates)</td>
<td><code>apps/trust::constraints</code></td>
</tr>
</tbody></table>
<p><strong>Definition of done:</strong> each row ends with â€œkernel no longer imports X; only imports <code>icn-kernel-api</code> and foundation crates.â€</p>
<h2>1. Identity &amp; Key Management</h2>
<p>Identity is the foundation of all authentication, trust computation, and ledger authorship in ICN. Every node, contract participant, and transaction is tied to a cryptographically verifiable decentralized identifier (DID).</p>
<h3>1.1 DID Format</h3>
<p><strong>Current:</strong> <code>did:icn:&lt;base58btc-ed25519-pubkey&gt;</code></p>
<p><strong>Decision: Single canonical public key per identity (v1)</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Simplicity: DID = public key = identity (direct mapping)</li>
<li>No registry: Self-certifying identifiers</li>
<li>Verifiable: Any peer can verify signatures without infrastructure</li>
<li>Compatible with existing Ed25519 tooling</li>
</ul>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li>âœ… Simple, auditable</li>
<li>âœ… No central registry dependency</li>
<li>âŒ Key compromise = identity loss (mitigated by rotation protocol)</li>
<li>âŒ No key hierarchy (can add later)</li>
</ul>
<p><strong>Future:</strong></p>
<ul>
<li>v2: DID documents with multiple keys (signing, encryption, delegation)</li>
<li>v3: HD wallet support for key derivation</li>
</ul>
<hr>
<h3>1.2 Key Derivation</h3>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Single key</strong></td>
<td>Simple, clear ownership</td>
<td>No sub-keys, rotation is identity change</td>
</tr>
<tr>
<td><strong>HD wallet (BIP32-like)</strong></td>
<td>Derive unlimited keys from seed</td>
<td>Complexity, seed compromise = total loss</td>
</tr>
<tr>
<td><strong>Master + derived</strong></td>
<td>Balance of simplicity and flexibility</td>
<td>Requires rotation protocol</td>
</tr>
</tbody></table>
<p><strong>Decision: Single master key + rotation protocol (v1)</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Start simple: one identity = one key</li>
<li>Implement robust key rotation with signed transition records</li>
<li>Add HD derivation in v2 when use cases emerge (e.g., per-contract keys)</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub struct KeyRotation {
    old_did: Did,
    new_did: Did,
    timestamp: u64,
    reason: RotationReason, // Scheduled, Compromised, Upgrade
    signature_old: Signature, // Signed by old key
    signature_new: Signature, // Signed by new key
}
</code></pre>
<hr>
<h3>1.3 Key Storage</h3>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Age-encrypted file</strong></td>
<td>Simple, portable</td>
<td>No hardware protection</td>
<td>Development, personal nodes</td>
</tr>
<tr>
<td><strong>OS keychain</strong></td>
<td>OS-managed, encrypted at rest</td>
<td>Platform-specific</td>
<td>Desktop apps</td>
</tr>
<tr>
<td><strong>Hardware security module</strong></td>
<td>Strongest protection</td>
<td>Requires hardware, expensive</td>
<td>Production, high-value</td>
</tr>
<tr>
<td><strong>TPM chip</strong></td>
<td>Built into modern hardware</td>
<td>Complex setup</td>
<td>Server deployments</td>
</tr>
</tbody></table>
<p><strong>Decision: Age-encrypted file (v1), pluggable for HSM/TPM (v2)</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Age encryption is simple, auditable (<a href="https://age-encryption.org/" target="_blank" rel="noopener">https://age-encryption.org/</a>)</li>
<li>Passphrase or YubiKey PIV slot for unlock</li>
<li>File-based is portable across machines</li>
<li>Clear migration path to HSM for production</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub trait KeyStore: Send + Sync {
    fn unlock(&amp;mut self, passphrase: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn lock(&amp;mut self);
    fn is_locked(&amp;self) -&gt; bool;
    fn get_keypair(&amp;self) -&gt; Result&lt;&amp;KeyPair&gt;;
    fn rotate(&amp;mut self, new_keypair: KeyPair) -&gt; Result&lt;KeyRotation&gt;;
}

pub struct AgeKeyStore { /* ... */ }
pub struct HsmKeyStore { /* ... */ }  // Future
</code></pre>
<p><strong>Storage path:</strong> <code>{data_dir}/identity.age</code> (for Linux defaults, typically <code>~/.local/share/icn/identity.age</code>)</p>
<hr>
<h3>1.4 Multi-Device Identity</h3>
<p><strong>Problem:</strong> Same identity across laptop, phone, server?</p>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Shared key</strong></td>
<td>Simple, truly same identity</td>
<td>Dangerous key duplication</td>
</tr>
<tr>
<td><strong>Delegate keys</strong></td>
<td>Separate keys per device, revocable</td>
<td>Requires delegation protocol</td>
</tr>
<tr>
<td><strong>Multi-sig</strong></td>
<td>No single point of failure</td>
<td>Complex, requires quorum</td>
</tr>
</tbody></table>
<p><strong>Decision: Delegate keys via signed capability grants (v2)</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Primary key signs delegation to device keys</li>
<li>Each device key has limited capabilities (time-bound, scope-bound)</li>
<li>Revocation: primary key publishes revocation signed statement</li>
<li>Preserves single canonical identity while allowing safe multi-device</li>
</ul>
<p><strong>Future Implementation:</strong></p>
<pre><code class="language-rust">pub struct Delegation {
    primary_did: Did,
    delegate_did: Did,
    capabilities: Vec&lt;Capability&gt;, // Sign contracts, read ledger, etc.
    expires_at: u64,
    signature: Signature, // Signed by primary key
}
</code></pre>
<p><strong>v1 compromise:</strong> Manual key export/import with clear warnings</p>
<hr>
<h3>1.5 SDIS Identity Extensions (Experimental)</h3>
<p><strong>Status:</strong> Phase S1-S5 complete, governance integration in progress</p>
<p>ICN is evolving toward SDIS (Sovereign Digital Identity System) to provide:</p>
<ul>
<li><strong>Permanent anchor-based identity</strong>: Key rotation without identity change</li>
<li><strong>Post-quantum signatures</strong>: Defense-in-depth against quantum threats</li>
<li><strong>Sybil resistance</strong>: VUI-based uniqueness verification</li>
</ul>
<h4>1.5.1 Architecture Overview</h4>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Anchor                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ ID: H(VUI || genesis)                                    â”‚â”‚
â”‚  â”‚ Created: timestamp                                       â”‚â”‚
â”‚  â”‚ Pathway: enrollment method                               â”‚â”‚
â”‚  â”‚ VUI Commitment: H(VUI)                                   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                           â”‚                                  â”‚
â”‚                           â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              KeyBundle v1 (current)                      â”‚â”‚
â”‚  â”‚  Ed25519 + ML-DSA hybrid signatures                      â”‚â”‚
â”‚  â”‚  X25519 encryption keys                                  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                           â”‚                                  â”‚
â”‚                           â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              KeyBundle v2 (after rotation)               â”‚â”‚
â”‚  â”‚  New hybrid keys, same anchor                            â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h4>1.5.2 Anchor-Based Identity</h4>
<p><strong>Problem:</strong> Traditional DIDs couple identity to public key, requiring identity change on key rotation.</p>
<p><strong>Solution:</strong> Anchors are permanent identity roots derived from VUI (Verifiable Unique Identifier):</p>
<ul>
<li>Anchor ID = H(VUI || genesis_random)</li>
<li>Keys bound to anchor via KeyBundles</li>
<li>Key rotation preserves anchor identity</li>
</ul>
<pre><code class="language-rust">pub struct Anchor {
    id: [u8; 32],           // Permanent identifier
    vui_commitment: [u8; 32], // H(VUI) for recovery verification
    pathway: EnrollmentPathway, // How identity was verified
    created_at: u64,
}

pub enum EnrollmentPathway {
    GovernmentId { country: [u8; 2], doc_type_hash: [u8; 8] },
    OrganizationalSponsorship { org_did: Did, org_internal_id_hash: [u8; 16] },
    BiometricCommitment { template_hash: [u8; 32] },
    WebOfTrust { vouchers: Vec&lt;Did&gt;, vouched_at: u64 },
    Genesis { reason: String }, // Bootstrap/testing
}
</code></pre>
<h4>1.5.3 Post-Quantum Hybrid Signatures</h4>
<p><strong>Threat Model:</strong> Quantum computers could break Ed25519 within ICN&#39;s operational lifetime.</p>
<p><strong>Solution:</strong> Hybrid signatures combining classical and post-quantum algorithms:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Classical</th>
<th>Post-Quantum</th>
</tr>
</thead>
<tbody><tr>
<td>Signature</td>
<td>Ed25519 (64 bytes)</td>
<td>ML-DSA-65 (3293 bytes)</td>
</tr>
<tr>
<td>Public Key</td>
<td>32 bytes</td>
<td>1952 bytes</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td>~100 bytes</td>
<td>~5.2 KB</td>
</tr>
</tbody></table>
<p><strong>Security:</strong> Both signatures must verifyâ€”attacker must break both algorithms.</p>
<pre><code class="language-rust">// icn-crypto-pq crate
pub struct HybridSignature {
    classical: Vec&lt;u8&gt;,  // Ed25519
    pq: Vec&lt;u8&gt;,         // ML-DSA
}

pub struct HybridKeypair {
    classical_signing: SigningKey,
    pq_keypair: MlDsaKeypair,
}

impl HybridKeypair {
    pub fn sign(&amp;self, message: &amp;[u8]) -&gt; HybridSignature;
    pub fn sign_classical_only(&amp;self, message: &amp;[u8]) -&gt; Signature; // Ephemeral use
}
</code></pre>
<h4>1.5.4 KeyBundle Rotation</h4>
<p>KeyBundles contain rotatable cryptographic keys bound to an anchor:</p>
<pre><code class="language-rust">pub struct KeyBundle {
    anchor: Anchor,
    version: u32,           // Monotonically increasing
    hybrid_keypair: HybridKeypair,
    x25519_secret: [u8; 32], // Encryption
    issued_at: u64,
    expires_at: Option&lt;u64&gt;,
}

pub struct RotationRequest {
    anchor_id: [u8; 32],
    old_version: u32,
    new_version: u32,       // Must be old + 1
    new_public: KeyBundlePublic,
    old_signature: HybridSignature, // Signed by old bundle
    reason: Option&lt;RotationReason&gt;,
}
</code></pre>
<p><strong>Rotation Protocol:</strong></p>
<ol>
<li>Generate new KeyBundle with incremented version</li>
<li>Sign rotation request with old KeyBundle</li>
<li>Publish rotation event to gossip network</li>
<li>Stewards verify and attest to the rotation</li>
<li>Old KeyBundle enters revocation period</li>
<li>New KeyBundle becomes active</li>
</ol>
<h4>1.5.5 VUI (Verifiable Unique Identifier)</h4>
<p><strong>Problem:</strong> Sybil attacksâ€”one person creating many identities.</p>
<p><strong>Solution:</strong> VUI computed via threshold PRF by steward network:</p>
<pre><code class="language-rust">// User provides identity data (hashed locally, never transmitted)
let id_hash = IdDataHash::from_data(&amp;identity_document, pathway);

// Stewards compute PRF partials (threshold secret sharing)
let partials: Vec&lt;PrfPartial&gt; = stewards.map(|s| s.compute_partial(&amp;id_hash));

// User combines partials to get VUI
let vui = Vui::from_partials(&amp;partials)?;

// VUI commitment stored in anchor (privacy-preserving)
let commitment = vui.commitment();
</code></pre>
<p><strong>Properties:</strong></p>
<ul>
<li>Same person â†’ same VUI (deterministic via threshold PRF)</li>
<li>VUI reveals nothing about person (PRF output)</li>
<li>Unlinkable without steward pepper shares</li>
<li>Distributed trustâ€”no single steward knows full pepper</li>
</ul>
<h4>1.5.6 Keystore v4 Format</h4>
<p>The keystore now supports SDIS with v4 format:</p>
<pre><code class="language-rust">struct StoredKeyV4 {
    version: u8,  // 4
    // Legacy fields (v3 compatibility)
    secret_bytes: [u8; 32],
    did_document: DidDocument,
    // ...

    // SDIS additions
    anchor: Option&lt;Anchor&gt;,
    keybundles: Vec&lt;StoredKeyBundleV4&gt;,
    current_keybundle_version: u32,
}
</code></pre>
<p><strong>API:</strong></p>
<pre><code class="language-rust">impl AgeKeyStore {
    // SDIS initialization
    pub fn init_sdis(&amp;mut self, anchor: Anchor, passphrase: &amp;[u8]) -&gt; Result&lt;&amp;KeyBundle&gt;;

    // KeyBundle rotation
    pub fn rotate_keybundle(&amp;mut self, passphrase: &amp;[u8]) -&gt; Result&lt;&amp;KeyBundle&gt;;

    // Accessors
    pub fn get_anchor(&amp;self) -&gt; Option&lt;&amp;Anchor&gt;;
    pub fn get_current_keybundle(&amp;self) -&gt; Result&lt;&amp;KeyBundle&gt;;
    pub fn has_sdis(&amp;self) -&gt; bool;
}
</code></pre>
<p><strong>Migration:</strong> Keystore auto-detects format and loads appropriately (v1â†’v2â†’v2.1â†’v3â†’v4).</p>
<h4>1.5.7 Implementation Status</h4>
<table>
<thead>
<tr>
<th>Component</th>
<th>Crate</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td>ML-DSA signatures</td>
<td>icn-crypto-pq</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>ML-KEM key exchange</td>
<td>icn-crypto-pq</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>Hybrid signatures</td>
<td>icn-crypto-pq</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>Threshold PRF</td>
<td>icn-crypto-pq</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>Anchor types</td>
<td>icn-identity</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>KeyBundle</td>
<td>icn-identity</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>VUI types</td>
<td>icn-identity</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>Keystore v4</td>
<td>icn-identity</td>
<td>âœ… Complete</td>
</tr>
<tr>
<td>Steward network</td>
<td>icn-steward</td>
<td>âœ… Phase S3.1</td>
</tr>
<tr>
<td>Zero-knowledge proofs</td>
<td>icn-zkp</td>
<td>âœ… Phase S4</td>
</tr>
<tr>
<td>Credential presentation</td>
<td>icn-gateway</td>
<td>âœ… Phase S5</td>
</tr>
<tr>
<td>SDIS governance</td>
<td>icn-governance</td>
<td>âœ… Phase S6</td>
</tr>
<tr>
<td>Enrollment flow</td>
<td>icn-enrollment</td>
<td>ğŸš§ Planned</td>
</tr>
</tbody></table>
<h4>1.5.8 Steward Network (Phase S3)</h4>
<p>The steward network provides essential services for SDIS including VUI computation, enrollment ceremonies, and key recovery.</p>
<p><strong>Architecture:</strong></p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Steward Network                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  Steward A   â”‚  â”‚  Steward B   â”‚  â”‚  Steward C   â”‚  ...      â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ PepperShare  â”‚  â”‚ PepperShare  â”‚  â”‚ PepperShare  â”‚           â”‚
â”‚  â”‚     [1]      â”‚  â”‚     [2]      â”‚  â”‚     [3]      â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                    â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                           â”‚                                      â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚                    â”‚ VUI Registry â”‚                              â”‚
â”‚                    â”‚   (Bloom)    â”‚                              â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Core Components:</strong></p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>StewardProfile</code></td>
<td>Steward identity, status, jurisdiction, stats</td>
</tr>
<tr>
<td><code>EnrollmentToken</code></td>
<td>Blind signature-based enrollment credentials</td>
</tr>
<tr>
<td><code>VuiRegistry</code></td>
<td>Bloom filter + exact set for uniqueness checks</td>
</tr>
<tr>
<td><code>EnrollmentCeremony</code></td>
<td>Threshold VUI computation workflow</td>
</tr>
<tr>
<td><code>RecoveryCeremony</code></td>
<td>Social recovery attestation workflow</td>
</tr>
</tbody></table>
<p><strong>Steward Profile:</strong></p>
<pre><code class="language-rust">pub struct StewardProfile {
    steward_did: Did,           // Node identity
    citizen_did: Did,           // Operator identity
    status: StewardStatus,      // Active/Suspended/Revoked/Pending
    jurisdiction_tier: JurisdictionTier,  // Tier1/Tier2/Tier3
    bond_amount: i64,           // Stake for honest behavior
    region: String,             // ISO 3166-1 alpha-2
    stats: StewardStats,        // Operational metrics
    token_signing_key: Vec&lt;u8&gt;, // For enrollment tokens
    pepper_share_commitment: [u8; 32], // Commitment to pepper share
}
</code></pre>
<p><strong>Enrollment Flow:</strong></p>
<ol>
<li>User generates VUI commitment from identity data</li>
<li>User presents proof-of-personhood to steward</li>
<li>Steward initiates enrollment ceremony</li>
<li>Threshold of stewards contribute pepper shares</li>
<li>VUI computed and checked against registry (Bloom filter)</li>
<li>If unique, token issued via blind signature</li>
<li>Token unblinded by user (unlinkable to issuance)</li>
</ol>
<p><strong>Blind Signature Tokens:</strong></p>
<pre><code class="language-rust">pub struct EnrollmentToken {
    token_id: [u8; 32],        // Unique identifier
    signature: Vec&lt;u8&gt;,        // Unblinded signature
    issuing_steward: Did,      // Public knowledge
    issued_at: u64,
    expires_at: u64,           // Default: 7 days
    vui_commitment: [u8; 32],  // Links to identity
}
</code></pre>
<p><strong>Recovery Ceremony:</strong></p>
<pre><code class="language-rust">pub enum RecoveryPhase {
    WaitingForAttestations,  // Collecting steward votes
    VerifyingEvidence,       // ZK proof verification
    BindingKeys,             // New keys â†’ anchor
    RevokingOldKeys,         // Old keys invalidated
    Completed,
    Failed,
    Rejected,
}
</code></pre>
<p><strong>Gossip Topics:</strong></p>
<ul>
<li><code>steward:announce</code> - Steward status broadcasts</li>
<li><code>steward:vui-sync</code> - VUI registry synchronization</li>
<li><code>steward:enrollment</code> - Enrollment ceremony coordination</li>
<li><code>steward:recovery</code> - Recovery ceremony coordination</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-rust">pub struct StewardConfig {
    vui_threshold: u32,              // Default: 3-of-5
    vui_total_shares: u32,
    token_validity_secs: u64,        // Default: 7 days
    bloom_expected_items: usize,     // Default: 1M
    bloom_false_positive_rate: f64,  // Default: 0.0001
    min_bond_amount: i64,            // Default: 1000
    heartbeat_interval_secs: u64,    // Default: 30
}
</code></pre>
<h4>1.5.9 Zero-Knowledge Proofs (Phase S4)</h4>
<p>The ZKP system enables privacy-preserving credential verification using STARK proofs.</p>
<p><strong>Core Components:</strong></p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>AirConstraint</code></td>
<td>Polynomial constraints for STARK prover</td>
</tr>
<tr>
<td><code>ProofGenerator</code></td>
<td>Creates zero-knowledge proofs from witness data</td>
</tr>
<tr>
<td><code>ProofVerifier</code></td>
<td>Verifies proofs without learning private data</td>
</tr>
<tr>
<td><code>ProofType</code></td>
<td>Attribute proof types (age, citizenship, membership)</td>
</tr>
</tbody></table>
<p><strong>Proof Types:</strong></p>
<pre><code class="language-rust">pub enum ProofType {
    AgeAtLeast { threshold: u8 },
    Citizenship { country_code: [u8; 2] },
    Membership { org_did: Did },
    NonRevocation,
}
</code></pre>
<p><strong>STARK Configuration:</strong></p>
<ul>
<li>Security level: 128 bits</li>
<li>Field: Goldilocks (64-bit prime)</li>
<li>Blowup factor: 4</li>
<li>FRI folding: 4</li>
</ul>
<h4>1.5.10 Credential Presentation (Phase S5)</h4>
<p>The credential presentation system provides three verification levels for identity credentials.</p>
<p><strong>Architecture:</strong></p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Verification Levels                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Level 1: QR Scan        â”‚ &lt;2s   â”‚ Offline â”‚ Ed25519           â”‚
â”‚  Level 2: NFC/BLE        â”‚ ~5s   â”‚ Offline â”‚ Hybrid Ed+ML-DSA  â”‚
â”‚  Level 3: Network        â”‚ ~10s  â”‚ Online  â”‚ STARK proofs      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>QR Encoding (137 bytes):</strong></p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
</tr>
</thead>
<tbody><tr>
<td>0-1</td>
<td>2</td>
<td>Magic bytes &quot;IC&quot;</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>Version</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>Proof type</td>
</tr>
<tr>
<td>4-19</td>
<td>16</td>
<td>Truncated anchor</td>
</tr>
<tr>
<td>20-51</td>
<td>32</td>
<td>Ephemeral public key</td>
</tr>
<tr>
<td>52-55</td>
<td>4</td>
<td>Relative expiry</td>
</tr>
<tr>
<td>56-71</td>
<td>16</td>
<td>Nonce</td>
</tr>
<tr>
<td>72-135</td>
<td>64</td>
<td>Ed25519 signature</td>
</tr>
<tr>
<td>136</td>
<td>1</td>
<td>Channels bitmap</td>
</tr>
</tbody></table>
<p><strong>Ephemeral Proof System:</strong></p>
<pre><code class="language-rust">pub struct EphemeralProof {
    anchor_id: [u8; 16],      // Truncated for QR
    ephemeral_pk: [u8; 32],   // Session key
    proof_type: ProofType,
    expires_at: u32,          // Relative seconds
    nonce: [u8; 16],          // Replay protection
    signature: [u8; 64],      // Ed25519
    channels: u8,             // Available upgrade paths
}

pub struct EphemeralBinding {
    proof_nonce: [u8; 16],
    anchor_id: [u8; 32],      // Full anchor
    ephemeral_pk: [u8; 32],
    hybrid_signature: Vec&lt;u8&gt;, // Ed25519 + ML-DSA
}
</code></pre>
<p><strong>Security Properties:</strong></p>
<ul>
<li>Replay protection via 16-byte nonces and LRU cache</li>
<li>Configurable expiry (max 24 hours)</li>
<li>Post-quantum security at Level 2+</li>
<li>Zero-knowledge proofs at Level 3</li>
</ul>
<h4>1.5.11 SDIS Governance (Phase S6)</h4>
<p>SDIS governance enables community oversight of the steward network and identity system.</p>
<p><strong>Proposal Types:</strong></p>
<pre><code class="language-rust">pub enum SdisProposal {
    AppointSteward { candidate: Did, sponsors: Vec&lt;Did&gt;, ... },
    RemoveSteward { steward: Did, reason: String, ... },
    SanctionSteward { steward: Did, penalty: StewardPenalty, ... },
    ReconfirmSteward { steward: Did, new_term_end: u64, ... },
    ModifyThreshold { threshold_type: ThresholdType, ... },
    ApproveAuthority { authority: InstitutionalAuthority },
    RevokeAuthority { authority_did: Did, reason: String, ... },
    RevocationAppeal { target: RevocationTarget, ... },
    SuspendSteward { steward: Did, reason: String, duration: u64 },
    ReinstateSteward { steward: Did, reason: String },
    UpdateJurisdictionTier { steward: Did, new_tier: JurisdictionTier, ... },
    ForceKeyRotation { steward: Did, reason: String },
}
</code></pre>
<p><strong>Voting Requirements:</strong></p>
<table>
<thead>
<tr>
<th>Proposal Type</th>
<th>Quorum</th>
<th>Approval</th>
<th>Timeout</th>
</tr>
</thead>
<tbody><tr>
<td>AppointSteward</td>
<td>60%</td>
<td>66%</td>
<td>14 days</td>
</tr>
<tr>
<td>RemoveSteward</td>
<td>70%</td>
<td>75%</td>
<td>7 days</td>
</tr>
<tr>
<td>SanctionSteward</td>
<td>60%</td>
<td>66%</td>
<td>3 days</td>
</tr>
<tr>
<td>ModifyThreshold</td>
<td>80%</td>
<td>80%</td>
<td>21 days</td>
</tr>
<tr>
<td>RevocationAppeal</td>
<td>50%</td>
<td>60%</td>
<td>30 days</td>
</tr>
</tbody></table>
<p><strong>Penalty Types:</strong></p>
<ul>
<li>Warning (recorded but no action)</li>
<li>FineCredits (deduct from bond)</li>
<li>SuspendDays (temporary suspension)</li>
<li>RevokeBond (permanent removal)</li>
</ul>
<hr>
<h2>2. Trust Graph Model</h2>
<p>The trust graph turns social relationships into machine-relevant security primitives. It gates access to resources, prioritizes computation, and resists Sybil attacksâ€”all without requiring global consensus on reputation.</p>
<h3>2.1 Trust Representation</h3>
<p><strong>Decision: Directed labeled trust edges with evidence chains</strong></p>
<p><strong>Graph Structure:</strong></p>
<pre><code class="language-rust">pub struct TrustEdge {
    source: Did,        // Who trusts
    target: Did,        // Who is trusted
    labels: Vec&lt;String&gt;, // &quot;partner&quot;, &quot;supplier&quot;, &quot;validator&quot;
    score: f64,         // 0.0 to 1.0
    evidence: Vec&lt;EvidenceRef&gt;, // Links to contracts, attestations
    expires_at: Option&lt;u64&gt;,
    created_at: u64,
}

pub struct Evidence {
    id: ContentHash,
    kind: EvidenceKind, // ContractFulfilled, Attestation, ThirdPartyVouch
    data: Vec&lt;u8&gt;,
    signatures: Vec&lt;(Did, Signature)&gt;,
}
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Directed:</strong> Alice trusts Bob â‰  Bob trusts Alice</li>
<li><strong>Labeled:</strong> Context matters (&quot;trust as accountant&quot; â‰  &quot;trust as mechanic&quot;)</li>
<li><strong>Evidence-based:</strong> Trust isn&#39;t arbitrary; it&#39;s backed by provable interactions</li>
<li><strong>Expiring:</strong> Trust decays without refresh</li>
</ul>
<hr>
<h3>2.2 Trust Computation</h3>
<p><strong>Decision: Local computation with transitive trust propagation (PageRank-like)</strong></p>
<p><strong>Algorithm (v2 - Unified):</strong></p>
<p>As of Phase 3, the trust computation algorithm is unified across all modes
(standalone and actor-backed) via <code>icn_trust::computation::compute_trust_score()</code>.</p>
<pre><code>TrustScore(A â†’ B) =
    DirectTrust(A â†’ B) * direct_weight +
    TransitiveTrust(A â†’ C â†’ B) * transitive_weight

where:
    DirectTrust = trust edge from A to B (0.0 if no edge exists)
    TransitiveTrust = Î£(Trust(A â†’ C) * Trust(C â†’ B)) / N
    
    Weights vary by trust graph type:
    - Social: 60% direct, 40% transitive (reputation spreads)
    - Economic: 80% direct, 20% transitive (payment history matters)
    - Technical: 90% direct, 10% transitive (node performance is personal)
    - Legacy/Default: 70% direct, 30% transitive (backward compatibility)
</code></pre>
<p><strong>Implementation:</strong></p>
<ul>
<li><strong>Location:</strong> <code>icn-trust/src/computation.rs</code> - shared algorithm</li>
<li><strong>Used by:</strong> <code>TrustGraph::compute_trust_score_weighted()</code> and <code>TrustManager::compute_trust_score_local()</code></li>
<li><strong>Guarantee:</strong> Standalone and actor-backed modes produce identical scores</li>
</ul>
<p><strong>Properties:</strong></p>
<ul>
<li><strong>Local computation:</strong> Each node computes trust from its perspective</li>
<li><strong>Transitive:</strong> &quot;Friend of a trusted friend&quot; has some trust</li>
<li><strong>Asymmetric:</strong> Different nodes see different trust scores</li>
<li><strong>Attack-resistant:</strong> Sybil nodes have low trust unless vouched by existing trusted nodes</li>
<li><strong>Consistent:</strong> Same algorithm everywhere (eliminates test/prod divergence)</li>
</ul>
<p><strong>Trust Classes (operational gates):</strong></p>
<pre><code class="language-rust">pub enum TrustClass {
    Isolated,    // Score 0.0-0.1: No interaction
    Known,       // Score 0.1-0.4: Seen, but not trusted
    Partner,     // Score 0.4-0.7: Regular interaction
    Federated,   // Score 0.7-1.0: High trust, extended rights
}
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li>Not consensus-based (no global truth)</li>
<li>Resistant to Sybil: new identities start with zero trust</li>
<li>Contextual: trust for one purpose doesn&#39;t imply trust for all</li>
<li>Unified: No divergence between dev/test and production behavior</li>
</ul>
<hr>
<h3>2.3 Bootstrap Trust</h3>
<p><strong>Problem:</strong> How does a new node establish initial trust?</p>
<p><strong>Decision: Manual vouching + invite codes + proof-of-work bootstrap</strong></p>
<p><strong>Approaches:</strong></p>
<ol>
<li><p><strong>Manual Introduction (primary):</strong></p>
<ul>
<li>Existing trusted node creates signed <code>IntroductionVoucher</code></li>
<li>New node presents voucher to network</li>
<li>Voucher grants initial trust score (e.g., 0.3) from introducer&#39;s perspective</li>
</ul>
</li>
<li><p><strong>Invite Codes (secondary):</strong></p>
<ul>
<li>Pre-generated by community nodes</li>
<li>Limited use (1-5 redemptions)</li>
<li>Provides minimal trust (0.1) for initial discovery</li>
</ul>
</li>
<li><p><strong>Proof-of-Work (fallback):</strong></p>
<ul>
<li>New node can solve computational puzzle</li>
<li>Proves Sybil resistance (cost per identity)</li>
<li>Grants minimal trust (0.05) for cold start</li>
</ul>
</li>
</ol>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub struct IntroductionVoucher {
    introducer: Did,
    introducee: Did,
    initial_trust: f64,
    message: String, // &quot;Alice from the Brooklyn Cooperative&quot;
    expires_at: u64,
    signature: Signature,
}
</code></pre>
<p><strong>Anti-patterns:</strong></p>
<ul>
<li>âŒ Open registration (Sybil vulnerability)</li>
<li>âŒ Pay-to-join (plutocracy)</li>
<li>âŒ Global reputation (centralization)</li>
</ul>
<hr>
<h3>2.4 Attack Resistance</h3>
<p><strong>Threats &amp; Mitigations:</strong></p>
<table>
<thead>
<tr>
<th>Attack</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Sybil (fake identities)</strong></td>
<td>Transitive trust; new DIDs start with zero trust</td>
</tr>
<tr>
<td><strong>Eclipse (isolate node)</strong></td>
<td>Multiple discovery mechanisms (mDNS, rendezvous, manual)</td>
</tr>
<tr>
<td><strong>Reputation farming</strong></td>
<td>Evidence-based trust; contracts must be fulfilled</td>
</tr>
<tr>
<td><strong>Trust graph poisoning</strong></td>
<td>Local computation; no global consensus on trust</td>
</tr>
<tr>
<td><strong>Key compromise</strong></td>
<td>Rotation protocol; evidence chains remain verifiable</td>
</tr>
</tbody></table>
<p><strong>Monitoring:</strong></p>
<ul>
<li>Nodes log trust score changes</li>
<li>Rapid trust oscillations flag suspicious behavior</li>
<li>Community visibility into trust edges (opt-in)</li>
</ul>
<hr>
<h2>3. Network Transport</h2>
<p>Networking provides authenticated, encrypted, NAT-resistant communication between peers. It is the backbone for all gossip, ledger sync, contract distribution, and distributed compute flows.</p>
<h3>3.1 Transport Protocol</h3>
<p><strong>Decision: QUIC with TLS 1.3 mutual authentication</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li><p><strong>QUIC advantages:</strong></p>
<ul>
<li>Multiplexed streams (no head-of-line blocking)</li>
<li>Built-in 0-RTT connection resumption</li>
<li>Better congestion control than TCP</li>
<li>NAT-friendly (UDP-based)</li>
</ul>
</li>
<li><p><strong>TLS 1.3 mutual auth:</strong></p>
<ul>
<li>Certificate bound to DID (public key)</li>
<li>Mutual authentication (both peers verify)</li>
<li>Forward secrecy</li>
<li>Standard, audited</li>
</ul>
</li>
</ul>
<p><strong>Important distinction</strong>: TLS verifies cryptographic identity only (proves the peer controls the DID&#39;s private key). Authorization decisions (whether this DID can publish, execute contracts, claim tasks, etc.) are enforced at higher layers via the trust graph. This separation allows flexible, context-dependent access control without coupling authentication to authorization.</p>
<p><strong>Stack:</strong></p>
<pre><code>Application (CCL, Ledger sync, Gossip)
    â†“
QUIC streams (multiplexed, flow-controlled)
    â†“
TLS 1.3 (encryption, authentication)
    â†“
UDP (transport)
</code></pre>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>âŒ TCP: head-of-line blocking, slower handshake</li>
<li>âŒ Noise Protocol: great, but QUIC+TLS is more mature</li>
<li>âš ï¸ Hybrid: Could add Noise inside QUIC for additional identity binding (v2)</li>
</ul>
<hr>
<h3>3.2 Peer Discovery</h3>
<p><strong>Decision: Multi-layered discovery (LAN + WAN + Manual)</strong></p>
<p><strong>Mechanisms:</strong></p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Protocol</th>
<th>Use Case</th>
<th>Trust</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LAN</strong></td>
<td>mDNS</td>
<td>Local network discovery</td>
<td>Low (verify via TLS)</td>
</tr>
<tr>
<td><strong>WAN</strong></td>
<td>Rendezvous servers</td>
<td>Internet-wide bootstrap</td>
<td>Medium (signed peer lists)</td>
</tr>
<tr>
<td><strong>Manual</strong></td>
<td>Config file / CLI</td>
<td>Explicit peering</td>
<td>High (admin intent)</td>
</tr>
<tr>
<td><strong>Gossip</strong></td>
<td>Peer exchange (PEX)</td>
<td>Network expansion</td>
<td>Low (verify via trust graph)</td>
</tr>
</tbody></table>
<p><strong>mDNS (LAN):</strong></p>
<pre><code>Service: _icn._udp.local
TXT records:
  did=did:icn:z...
  version=0.1.0
  capabilities=ledger,contracts
  port=7777
</code></pre>
<p><strong>Rendezvous (WAN):</strong></p>
<ul>
<li>Operated by community (anyone can run one)</li>
<li>Return signed peer list with timestamps</li>
<li>Clients verify signatures against known rendezvous DID keys</li>
<li>No single point of failure (multiple rendezvous in config)</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub struct PeerInfo {
    did: Did,
    addrs: Vec&lt;SocketAddr&gt;,
    capabilities: HashSet&lt;String&gt;,
    last_seen: u64,
}

pub enum DiscoverySource {
    Mdns,
    Rendezvous(Did),
    Manual,
    Gossip(Did), // Learned from peer X
}
</code></pre>
<hr>
<h3>3.3 NAT Traversal</h3>
<p><strong>Decision: Hole punching + relay fallback</strong></p>
<p><strong>Approach:</strong></p>
<ol>
<li><p><strong>Direct connection (best case):</strong></p>
<ul>
<li>Both peers have public IPs or are LAN-local</li>
<li>Direct QUIC connection</li>
</ul>
</li>
<li><p><strong>Hole punching (common case):</strong></p>
<ul>
<li>Use STUN-like protocol to discover public IP/port</li>
<li>Coordinate simultaneous UDP send (punch through NAT)</li>
<li>~80% success rate</li>
</ul>
</li>
<li><p><strong>Relay (fallback):</strong></p>
<ul>
<li>Community-run relay nodes</li>
<li>Encrypt end-to-end; relay only forwards packets</li>
<li>Relay nodes selected from high-trust peers</li>
<li>Temporary (establish, then try hole punch in background)</li>
</ul>
</li>
</ol>
<p><strong>Relay incentives:</strong></p>
<ul>
<li>Relay operators gain trust score</li>
<li>Nodes can donate bandwidth to relay pool</li>
<li>Relay usage is temporary (encourage direct connections)</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub struct ConnectionPath {
    peer: Did,
    path: ConnectionType,
}

pub enum ConnectionType {
    Direct(SocketAddr),
    Relayed { via: Did, relay_addr: SocketAddr },
    Failed(String),
}
</code></pre>
<hr>
<h3>3.4 Connection Management</h3>
<p><strong>Decision: Trust-gated connection limits with backpressure</strong></p>
<p><strong>Limits (per node):</strong></p>
<pre><code class="language-rust">pub struct ConnectionLimits {
    max_total: usize,      // 500 (adjustable)
    max_per_trust_class: HashMap&lt;TrustClass, usize&gt;,
    // Isolated: 10, Known: 50, Partner: 200, Federated: 240

    max_streams_per_peer: usize, // 32
    max_inflight_bytes: usize,   // 10 MB per peer
}
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li>Prevent resource exhaustion</li>
<li>Prioritize trusted peers</li>
<li>Shed load under attack (drop Isolated/Known first)</li>
<li>Backpressure propagates to application layer</li>
</ul>
<p><strong>Health checks:</strong></p>
<ul>
<li>Periodic ping/pong (30s interval)</li>
<li>Idle timeout (5 min for Isolated, 30 min for Partners)</li>
<li>Detect dead connections, free resources</li>
</ul>
<hr>
<h2>4. Ledger Design</h2>
<p>The ledger encodes cooperative economic reality as an append-only, tamper-evident Merkle-DAG. It enables mutual credit, transparent accounting, and eventual consistency without requiring consensus on global state.</p>
<h3>4.1 Data Model</h3>
<p><strong>Decision: Double-entry append-only ledger with Merkle-DAG structure</strong></p>
<p><strong>Why double-entry?</strong></p>
<ul>
<li>Conservation law: Î£ debits = Î£ credits (every transaction)</li>
<li>Mutual credit requires balanced books</li>
<li>Auditable: any peer can verify invariants</li>
</ul>
<p><strong>Why Merkle-DAG?</strong></p>
<ul>
<li>Content-addressable: each entry has unique hash</li>
<li>Tamper-evident: changing history breaks hashes</li>
<li>Forkable: offline work creates branches, merge later</li>
<li>Enables efficient sync (exchange hashes, fetch missing)</li>
</ul>
<p><strong>Structure:</strong></p>
<pre><code class="language-rust">pub struct JournalEntry {
    id: ContentHash,          // SHA-256 of canonical serialization
    timestamp: u64,           // Local timestamp (not consensus)
    author: Did,              // Who created this entry
    contract_ref: Option&lt;ContentHash&gt;, // Which contract authorized this

    accounts: Vec&lt;AccountDelta&gt;,

    parents: Vec&lt;ContentHash&gt;, // Previous entries (Merkle-DAG links)
    signature: Signature,      // Signed by author
}

pub struct AccountDelta {
    account_id: Did,          // Could be person, organization, resource
    currency: String,         // &quot;USD&quot;, &quot;hours&quot;, &quot;kwh&quot;
    debit: Option&lt;i64&gt;,       // Positive values
    credit: Option&lt;i64&gt;,      // Positive values
}

// Invariant enforced at creation:
// Î£ debits == Î£ credits (per currency)
</code></pre>
<p><strong>Example Transaction:</strong></p>
<pre><code>Alice delivers 10 hours of web design to Bob&#39;s coop.

Entry:
  debits:  Alice/hours: 10
  credits: BobCoop/hours: 10

Alice&#39;s balance: +10 hours (owed to her)
BobCoop&#39;s balance: -10 hours (owes)
</code></pre>
<hr>
<h3>4.2 Conflict Resolution</h3>
<p><strong>Problem:</strong> Two nodes create conflicting entries while offline.</p>
<p><strong>Decision: Deterministic merge with constraint checking</strong></p>
<p><strong>Algorithm:</strong></p>
<ol>
<li><strong>Detect fork:</strong> Entry has multiple children for same parent</li>
<li><strong>Order canonically:</strong> Sort by <code>(timestamp, author_did, entry_id)</code></li>
<li><strong>Replay both branches:</strong><ul>
<li>Compute balance after each branch</li>
<li>Check invariants (no overdraft beyond credit limits)</li>
</ul>
</li>
<li><strong>Merge or quarantine:</strong><ul>
<li>If both branches valid: merge (both applied)</li>
<li>If one invalid: discard invalid branch</li>
<li>If both invalid: quarantine, require manual resolution</li>
</ul>
</li>
</ol>
<p><strong>Contract-level rules:</strong></p>
<ul>
<li>Contracts can specify stricter merge rules</li>
<li>E.g., &quot;only one party can create entries&quot; (no conflict possible)</li>
<li>E.g., &quot;sequential numbering required&quot; (detect gaps)</li>
</ul>
<p><strong>Quarantine:</strong></p>
<pre><code class="language-rust">pub struct QuarantinedEntry {
    entry: JournalEntry,
    reason: QuarantineReason,
    conflicts_with: Vec&lt;ContentHash&gt;,
    resolution: Option&lt;Resolution&gt;, // Human or contract decision
}

pub enum QuarantineReason {
    InvariantViolation(String), // Overdraft, double-spend
    ConflictingTimestamp,
    InvalidSignature,
}
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li>Deterministic: all nodes reach same conclusion</li>
<li>Conservative: preserve data, don&#39;t auto-delete</li>
<li>Auditable: history of conflicts and resolutions</li>
</ul>
<hr>
<h3>4.3 Currency Model</h3>
<p><strong>Decision: Multi-currency with per-contract currency definitions (v1)</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li><p>Different cooperatives use different units</p>
<ul>
<li>Time banks: hours</li>
<li>Energy coops: kWh</li>
<li>Fiat-backed: USD/EUR</li>
<li>Resource credits: compute, storage</li>
</ul>
</li>
<li><p>Currency is just a string label</p>
</li>
<li><p>No built-in exchange rates (contracts handle that)</p>
</li>
<li><p>No global supply (each contract defines issuance)</p>
</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub struct Currency {
    symbol: String,       // &quot;hours&quot;, &quot;USD&quot;, &quot;kwh&quot;
    decimals: u8,         // Precision (e.g., 2 for cents)
    issuer: Option&lt;Did&gt;,  // Who can issue? None = mutual credit
}
</code></pre>
<p><strong>Mutual credit currencies:</strong></p>
<ul>
<li>No central issuer</li>
<li>Created by transaction (balanced debit/credit)</li>
<li>Can have credit limits per participant</li>
</ul>
<p><strong>Asset-backed currencies:</strong></p>
<ul>
<li>Issuer holds reserves</li>
<li>Can redeem for external asset</li>
<li>Requires trusted issuer</li>
</ul>
<p><strong>v2: Multi-issuer currencies with attestations</strong></p>
<hr>
<h3>4.4 Credit Limits</h3>
<p><strong>Decision: Per-participant, per-currency limits set by contract</strong></p>
<p><strong>Mechanism:</strong></p>
<pre><code class="language-rust">pub struct CreditLimit {
    participant: Did,
    currency: String,
    max_negative_balance: i64, // How much can they owe?
    max_positive_balance: i64, // How much can be owed to them?
    set_by: Did,               // Who set this limit?
    effective_date: u64,
}
</code></pre>
<p><strong>Who sets limits?</strong></p>
<ul>
<li><strong>Mutual agreement:</strong> Both parties sign</li>
<li><strong>Contract rules:</strong> Automatic based on participation</li>
<li><strong>Community vote:</strong> Governance process</li>
</ul>
<p><strong>Dynamic adjustment:</strong></p>
<ul>
<li>Limits can increase with trust score</li>
<li>Proven track record â†’ higher credit line</li>
<li>Contract can automate: &quot;10% increase per fulfilled contract&quot;</li>
</ul>
<p><strong>Default limits (conservative):</strong></p>
<ul>
<li>New participants: Â±100 units</li>
<li>Increases require explicit action</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>Prevent runaway debt</li>
<li>Encourage accountability</li>
<li>Reflects real-world credit relationships</li>
</ul>
<hr>
<h3>4.5 Privacy</h3>
<p><strong>Decision: Semi-private by default, opt-in transparency (v1)</strong></p>
<p><strong>Visibility levels:</strong></p>
<table>
<thead>
<tr>
<th>Data</th>
<th>Who can see?</th>
<th>Rationale</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Account balances</strong></td>
<td>Account owner + contract participants</td>
<td>Privacy</td>
</tr>
<tr>
<td><strong>Transaction amounts</strong></td>
<td>Transaction parties + auditors (if designated)</td>
<td>Selective disclosure</td>
</tr>
<tr>
<td><strong>Transaction existence</strong></td>
<td>Contract participants</td>
<td>Provable participation</td>
</tr>
<tr>
<td><strong>Merkle roots</strong></td>
<td>Public</td>
<td>Integrity verification</td>
</tr>
</tbody></table>
<p><strong>v2: Zero-knowledge proofs</strong></p>
<ul>
<li>Prove balance constraints without revealing amount</li>
<li>Prove transaction validity without revealing parties</li>
<li>Requires additional crypto (zk-SNARKs or Bulletproofs)</li>
</ul>
<p><strong>Auditor role:</strong></p>
<ul>
<li>Contracts can designate auditors</li>
<li>Auditors receive encrypted ledger entries</li>
<li>Can verify compliance without full visibility to everyone</li>
</ul>
<hr>
<h3>4.6 Economic Receipt Chain (Sprint 8-10)</h3>
<p><strong>Problem:</strong> Governance decisions (e.g., &quot;approve $1000 for project X&quot;) must be traceable all the way to ledger entries with cross-node verifiable determinism.</p>
<p><strong>Decision: CanonicalReceipt trait + deterministic hash chain</strong></p>
<p><strong>Architecture:</strong></p>
<pre><code>GovernanceProposal â†’ DecisionReceipt â†’ AllocationReceipt â†’ SettlementIntent â†’ LedgerEntry
         â†“                  â†“                  â†“                  â†“              â†“
   (stores vote)    (canonical_hash)   (canonical_hash)   (canonical_hash)  (decision_hash)
</code></pre>
<p><strong>Key types (icn-kernel-api):</strong></p>
<pre><code class="language-rust">/// Trait for receipts that can be verified across nodes
pub trait CanonicalReceipt {
    /// Compute deterministic Blake3 hash (order-independent)
    fn canonical_hash(&amp;self) -&gt; Hash;
    
    /// Node-local receipt ID
    fn receipt_id(&amp;self) -&gt; &amp;str;
    
    /// Links to upstream receipts (governance, parent allocations)
    fn provenance_anchors(&amp;self) -&gt; Vec&lt;Hash&gt;;
}

/// Allocation of resources from a governance decision
pub struct AllocationReceipt {
    pub decision_receipt_id: String,
    pub decision_hash: Hash,       // Cross-node anchor
    pub scope: ScopeLevel,
    pub intents: Vec&lt;SettlementIntent&gt;,
    pub timestamp: u64,
}

/// Declarative economic intent (what to do, not how)
pub struct SettlementIntent {
    pub decision_receipt_id: String,
    pub decision_hash: Hash,
    pub from: String,              // Treasury/source
    pub to: String,                // Recipient
    pub amount: u64,
    pub unit: String,              // &quot;USD&quot;, &quot;HOURS&quot;, etc.
    pub asset_type: Option&lt;AssetType&gt;,
}
</code></pre>
<p><strong>Invariants:</strong></p>
<ol>
<li><strong>Canonical hash is order-independent:</strong> <code>intent_hashes</code> sorted before hashing</li>
<li><strong>Same inputs â†’ same hash across nodes:</strong> Blake3 over deterministic serialization</li>
<li><strong>Provenance is queryable:</strong> <code>decision_hash</code> links ledger entries back to governance</li>
</ol>
<p><strong>API Endpoints:</strong></p>
<table>
<thead>
<tr>
<th>Endpoint</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>GET /v1/receipts/chain?decision_hash=...</code></td>
<td>Get full receipt chain for a decision</td>
</tr>
<tr>
<td><code>GET /v1/receipts/allocations/{hash}</code></td>
<td>Get allocation by canonical hash</td>
</tr>
<tr>
<td><code>GET /v1/receipts/intents/{hash}</code></td>
<td>Get intent by canonical hash</td>
</tr>
<tr>
<td><code>GET /v1/ledger/{coop}/entries/by-decision?decision_hash=...</code></td>
<td>Ledger entries with provenance</td>
</tr>
</tbody></table>
<p><strong>Why this matters:</strong></p>
<ul>
<li>Governance becomes auditable: every spend links to a vote</li>
<li>Cross-node equality: canonical hashes match regardless of which node created them</li>
<li>Disputes become tractable: deterministic chain enables arbitration</li>
<li>CCL gains teeth: contracts can verify receipt chains before acting</li>
</ul>
<hr>
<h2>5. Contract Execution (CCL)</h2>
<p>Contracts define rules governing economic or procedural interactions, executed deterministically across all nodes. They enable cooperatives to codify agreements without trusting a central authority.</p>
<h3>5.1 Language Design</h3>
<p><strong>Decision: Domain-specific language (DSL) for v1, WASM for v2</strong></p>
<p><strong>v1: CCL DSL (deterministic interpreter)</strong></p>
<p><strong>Goals:</strong></p>
<ul>
<li>Express cooperative agreements</li>
<li>Safe (no arbitrary code execution)</li>
<li>Deterministic (same inputs â†’ same outputs)</li>
<li>Auditable (human-readable)</li>
</ul>
<p><strong>Features:</strong></p>
<pre><code>contract TimeBank {
  participants: Set&lt;Did&gt;
  currency: &quot;hours&quot;

  rule credit_limit {
    for p in participants:
      limit(p, &quot;hours&quot;, -100, +100)
  }

  rule record_service {
    require: sender in participants
    require: recipient in participants
    require: hours &gt; 0

    ledger.transfer(recipient, sender, hours, &quot;hours&quot;)
  }

  trigger monthly_report {
    schedule: &quot;0 0 1 * *&quot;  // Cron-like
    action: generate_report()
  }
}
</code></pre>
<p><strong>Properties:</strong></p>
<ul>
<li><strong>Not Turing-complete</strong> (no infinite loops)</li>
<li><strong>Bounded execution</strong> (fuel metering)</li>
<li><strong>Capability-based</strong> (explicit permissions)</li>
<li><strong>Versioned</strong> (contracts include version, can upgrade)</li>
</ul>
<p><strong>v2: WASM sandbox</strong></p>
<ul>
<li>Compile Rust/AssemblyScript to WASM</li>
<li>Run in <code>wasmtime</code> with strict gas limits</li>
<li>Capability injection (contracts request permissions)</li>
<li>Better for complex logic</li>
</ul>
<hr>
<h3>5.2 Determinism</h3>
<p><strong>Critical:</strong> Same contract + same inputs = same outputs on all nodes</p>
<p><strong>Guarantees:</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Approach</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Time</strong></td>
<td>No <code>now()</code> access; timestamp passed as input</td>
</tr>
<tr>
<td><strong>Randomness</strong></td>
<td>Deterministic PRNG seeded by contract hash</td>
</tr>
<tr>
<td><strong>Ordering</strong></td>
<td>Inputs sorted canonically before execution</td>
</tr>
<tr>
<td><strong>Floating point</strong></td>
<td>Use fixed-point math (i64 with decimals)</td>
</tr>
<tr>
<td><strong>External data</strong></td>
<td>No network access; oracle data passed as signed inputs</td>
</tr>
</tbody></table>
<p><strong>Testing:</strong></p>
<ul>
<li>Fuzzing with proptest</li>
<li>Differential testing (run on multiple platforms, compare outputs)</li>
<li>Golden files for regression</li>
</ul>
<hr>
<h3>5.3 Capabilities</h3>
<p><strong>Decision: Explicit capability model (principle of least privilege)</strong></p>
<p><strong>Capabilities:</strong></p>
<pre><code class="language-rust">pub enum Capability {
    ReadLedger { accounts: Vec&lt;Did&gt; },
    WriteLedger { accounts: Vec&lt;Did&gt; },
    SendMessage { to: Did },
    ReadState { keys: Vec&lt;String&gt; },
    WriteState { keys: Vec&lt;String&gt; },
    CreateSubContract,
    InvokeContract { contract: ContentHash },
}
</code></pre>
<p><strong>Grant mechanism:</strong></p>
<pre><code class="language-rust">pub struct ContractInstallation {
    code_hash: ContentHash,
    installed_by: Did,
    capabilities: Vec&lt;Capability&gt;,
    participants: Vec&lt;Did&gt;,
    signatures: Vec&lt;(Did, Signature)&gt;, // All participants must sign
}
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li>Participants know exactly what a contract can do</li>
<li>Sandboxing: contracts can&#39;t access data they shouldn&#39;t</li>
<li>Auditable: review capabilities before signing</li>
</ul>
<hr>
<h3>5.4 Upgradability</h3>
<p><strong>Decision: Explicit migration with participant consent</strong></p>
<p><strong>Process:</strong></p>
<ol>
<li>Propose new contract version (code_hash_v2)</li>
<li>Include migration function: <code>migrate(old_state) -&gt; new_state</code></li>
<li>Participants review and sign</li>
<li>On consensus: run migration, switch to new version</li>
</ol>
<p><strong>Safety:</strong></p>
<ul>
<li>Old contract remains in history (auditable)</li>
<li>Migration is deterministic (all nodes get same result)</li>
<li>Rollback: re-instantiate old contract with migrated state</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">pub struct ContractUpgrade {
    old_version: ContentHash,
    new_version: ContentHash,
    migration: MigrationCode,
    proposed_by: Did,
    approvals: Vec&lt;(Did, Signature)&gt;,
    threshold: usize, // e.g., 2/3 of participants
}
</code></pre>
<p><strong>Emergency: Security upgrade without consensus?</strong></p>
<ul>
<li>Risky; prefer participant coordination</li>
<li>Could allow &quot;security council&quot; capability (opt-in governance)</li>
</ul>
<hr>
<h3>5.5 Distributed Contract Deployment</h3>
<p><strong>Decision: Gossip-based distribution with trust-gated authorization (Phase 9)</strong></p>
<p><strong>Architecture:</strong></p>
<p>Contracts are distributed across the ICN network using the gossip protocol, enabling decentralized deployment without central coordination while maintaining security through trust-based authorization.</p>
<p><strong>Components:</strong></p>
<pre><code class="language-rust">pub struct ContractActor {
    did: Did,
    runtime: Arc&lt;RwLock&lt;ContractRuntime&gt;&gt;,
    trust_graph: Option&lt;Arc&lt;RwLock&lt;TrustGraph&gt;&gt;&gt;,
}

impl ContractActor {
    pub async fn deploy_contract(
        &amp;self,
        contract: Contract,
        installation: ContractInstallation,
    ) -&gt; Result&lt;ContentHash&gt;;

    pub async fn execute_rule(
        &amp;self,
        request: ContractExecutionRequest,
    ) -&gt; Result&lt;ExecutionResult&gt;;

    pub async fn handle_deployment_message(
        &amp;self,
        msg: ContractDeploymentMessage,
    ) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p><strong>Deployment Flow:</strong></p>
<ol>
<li><p><strong>Local Installation</strong></p>
<ul>
<li>Deployer validates contract structure (<code>contract.validate()</code>)</li>
<li>Creates <code>ContractInstallation</code> with capabilities and signatures</li>
<li>Generates deterministic code hash (SHA-256 of contract + participants)</li>
<li>Installs locally via <code>ContractRuntime::install_contract_with_metadata()</code></li>
</ul>
</li>
<li><p><strong>Trust Authorization</strong></p>
<ul>
<li>Check deployer trust score via TrustGraph</li>
<li>Require <code>trust_score &gt;= MIN_DEPLOYER_TRUST</code> (0.4 = &quot;Known&quot; tier)</li>
<li>Reject deployments from untrusted nodes to prevent spam</li>
</ul>
</li>
<li><p><strong>Gossip Distribution</strong></p>
<ul>
<li>Serialize contract to <code>ContractDeploymentMessage</code> (serde_json)</li>
<li>Publish to <code>contracts:deploy</code> topic (AccessControl::Public)</li>
<li>Gossip propagates to all subscribed peers via push/pull</li>
</ul>
</li>
<li><p><strong>Peer Reception</strong></p>
<ul>
<li>Notification callback triggered on new entry</li>
<li>Deserialize <code>ContractDeploymentMessage</code></li>
<li>Verify deployer trust score &gt;= MIN_DEPLOYER_TRUST</li>
<li>Validate contract structure and participant signatures</li>
<li>Install locally if all checks pass</li>
</ul>
</li>
</ol>
<p><strong>Trust-Based Authorization:</strong></p>
<table>
<thead>
<tr>
<th>Trust Score</th>
<th>Class</th>
<th>Contract Deployment</th>
<th>Contract Execution</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; 0.1</td>
<td>Isolated</td>
<td>âŒ Rejected</td>
<td>âŒ (unless participant)</td>
</tr>
<tr>
<td>0.1 - 0.4</td>
<td>Known</td>
<td>âŒ Rejected</td>
<td>âŒ (unless participant)</td>
</tr>
<tr>
<td>0.4 - 0.7</td>
<td>Partner</td>
<td>âœ… Accepted</td>
<td>âœ… (if <code>min_caller_trust</code> allows)</td>
</tr>
<tr>
<td>0.7+</td>
<td>Federated</td>
<td>âœ… Accepted</td>
<td>âœ… (if <code>min_caller_trust</code> allows)</td>
</tr>
</tbody></table>
<p><strong>Execution Authorization:</strong></p>
<pre><code class="language-rust">pub struct ContractInstallation {
    // ... other fields
    min_caller_trust: Option&lt;f64&gt;, // Per-contract trust threshold
}
</code></pre>
<ul>
<li><strong>Participants</strong>: Always authorized to execute</li>
<li><strong>Non-participants</strong>: Require <code>trust_score &gt;= min_caller_trust</code></li>
<li><strong>None</strong>: Participant-only execution (most restrictive)</li>
</ul>
<p><strong>Defense-in-Depth:</strong></p>
<ol>
<li><strong>TLS Layer</strong>: Certificate-based peer authentication</li>
<li><strong>Gossip Layer</strong>: Topic subscription with trust gates (Phase 8C)</li>
<li><strong>Contract Layer</strong>: Deployer trust + contract-level execution control</li>
<li><strong>Capability Layer</strong>: Explicit permissions for ledger/state access</li>
</ol>
<p><strong>Message Types:</strong></p>
<pre><code class="language-rust">pub struct ContractDeploymentMessage {
    code_hash: ContentHash,
    contract: Contract,
    installation: ContractInstallation,
    deployer_signature: Vec&lt;u8&gt;,
}

pub struct ContractExecutionRequest {
    code_hash: ContentHash,
    rule_name: String,
    args: HashMap&lt;String, Value&gt;,
    caller: Did,
    timestamp: u64, // For deterministic execution
}

pub struct ContractExecutionResponse {
    result: ExecutionResult,
    success: bool,
    error: Option&lt;String&gt;,
}
</code></pre>
<p><strong>Metrics &amp; Observability:</strong></p>
<p>All contract operations tracked via Prometheus:</p>
<ul>
<li><code>icn_contract_installed_total</code> - Gauge of installed contracts</li>
<li><code>icn_contract_deployments_total</code> - Deployments initiated</li>
<li><code>icn_contract_deployments_received_total</code> - Deployments from network</li>
<li><code>icn_contract_deployments_rejected_trust_total</code> - Trust-based rejections</li>
<li><code>icn_contract_executions_total</code> - Rule executions (by contract + rule)</li>
<li><code>icn_contract_executions_failed_total</code> - Failed executions</li>
<li><code>icn_contract_execution_fuel_used</code> - Histogram of fuel consumption</li>
<li><code>icn_contract_execution_duration_seconds</code> - Execution time distribution</li>
</ul>
<p><strong>Security Properties:</strong></p>
<p>âœ… <strong>Spam Prevention</strong>: Only trusted deployers (score &gt;= 0.4) can distribute
âœ… <strong>Sybil Resistance</strong>: Trust graph prevents identity farming
âœ… <strong>Participant Control</strong>: All participants must sign installation
âœ… <strong>Capability Isolation</strong>: Contracts sandboxed by explicit capabilities
âœ… <strong>Execution Limits</strong>: Fuel metering prevents DoS
âœ… <strong>Auditability</strong>: All deployments logged with deployer DID</p>
<p><strong>Tradeoffs:</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Chosen</th>
<th>Alternative</th>
<th>Rationale</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Distribution</strong></td>
<td>Gossip</td>
<td>Central registry</td>
<td>Decentralized, resilient to failures</td>
</tr>
<tr>
<td><strong>Authorization</strong></td>
<td>Trust-based</td>
<td>Stake-based</td>
<td>Aligns with ICN&#39;s web-of-participation model</td>
</tr>
<tr>
<td><strong>Serialization</strong></td>
<td>Serde-json</td>
<td>Bincode/CBOR</td>
<td>Human-readable, debuggable</td>
</tr>
<tr>
<td><strong>Code Hash</strong></td>
<td>Contract + participants</td>
<td>Bytecode only</td>
<td>Ties deployment to specific participants</td>
</tr>
<tr>
<td><strong>Trust Threshold</strong></td>
<td>0.4 (Partner)</td>
<td>Higher/Lower</td>
<td>Balances spam prevention with accessibility</td>
</tr>
</tbody></table>
<p><strong>Future Enhancements:</strong></p>
<ul>
<li><strong>v2</strong>: Contract marketplace with ratings/reviews</li>
<li><strong>v3</strong>: Multi-signature deployment workflows</li>
<li><strong>v4</strong>: Contract templates with instantiation parameters</li>
<li><strong>v5</strong>: On-chain governance for system contracts</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li>ContractActor: <code>icn-ccl/src/actor.rs</code> (deployment + execution)</li>
<li>Messages: <code>icn-ccl/src/messages.rs</code> (serialization types)</li>
<li>Runtime: <code>icn-ccl/src/runtime.rs</code> (contract storage + metadata)</li>
<li>Supervisor: <code>icn-core/src/supervisor.rs:134-185</code> (gossip integration)</li>
<li>Metrics: <code>icn-obs/src/metrics.rs:259-615</code> (observability)</li>
</ul>
<hr>
<h2>6. Gossip &amp; Synchronization</h2>
<p>Gossip is the substrate for all coordination: dissemination, consistency, and convergence. It provides causal consistency without consensus, enabling local-first operation with eventual network-wide agreement.</p>
<h3>6.1 Consistency Model</h3>
<p><strong>Decision: Causal consistency with anti-entropy</strong></p>
<p><strong>Properties:</strong></p>
<ul>
<li><strong>Causal:</strong> If A caused B, all nodes see A before B</li>
<li><strong>Eventual:</strong> All nodes converge (no partition forever)</li>
<li><strong>Local-first:</strong> Nodes apply changes immediately, sync later</li>
</ul>
<p><strong>Not:</strong> Strong consistency (would require consensus, kills availability)</p>
<hr>
<h4>6.1.1 Why Not Consensus?</h4>
<p>ICN deliberately avoids consensus algorithms (Raft, Paxos, PBFT) for core substrate operations:</p>
<ul>
<li><strong>Availability</strong>: Consensus requires quorum; partitions block progress</li>
<li><strong>Autonomy</strong>: Nodes must wait for network agreement before acting locally</li>
<li><strong>Complexity</strong>: Leader election, view changes, and reconfiguration add failure modes</li>
<li><strong>Centralization</strong>: Consensus creates implicit coordination points and attack surfaces</li>
<li><strong>Liveness coupling</strong>: A single slow node can block the entire system</li>
</ul>
<p>ICN chooses <strong>causal consistency</strong> and <strong>trust-local computation</strong> instead. Conflicts are detected and resolved deterministically. This maximizes resilience and aligns with cooperative values of autonomy.</p>
<p><strong>Where consensus may appear in v2</strong>: Governance layers requiring global agreement (e.g., network-wide protocol upgrades), but never for day-to-day ledger/contract/compute operations.</p>
<hr>
<p><strong>Mechanism: Vector clocks</strong></p>
<pre><code class="language-rust">pub struct VectorClock {
    clock: HashMap&lt;Did, u64&gt;, // Node â†’ sequence number
}

impl VectorClock {
    pub fn happened_before(&amp;self, other: &amp;VectorClock) -&gt; bool {
        // Returns true if self causally precedes other
    }
}
</code></pre>
<p><strong>Causality tracking:</strong></p>
<ul>
<li>Each entry includes vector clock</li>
<li>Nodes merge clocks on sync</li>
<li>Detect conflicts (concurrent entries)</li>
</ul>
<hr>
<h3>6.2 Sync Protocol</h3>
<p><strong>Decision: Hybrid push/pull with bloom filters</strong></p>
<p><strong>Protocol:</strong></p>
<ol>
<li><p><strong>Announce (push):</strong></p>
<ul>
<li>Node creates new entry â†’ send announcement to connected peers</li>
<li>Announcement = (entry_hash, vector_clock, author)</li>
</ul>
</li>
<li><p><strong>Request (pull):</strong></p>
<ul>
<li>Peer checks: do I have this entry?</li>
<li>If not: request full entry</li>
</ul>
</li>
<li><p><strong>Anti-entropy (periodic):</strong></p>
<ul>
<li>Exchange bloom filters of recent entries</li>
<li>Identify missing entries</li>
<li>Fetch missing</li>
</ul>
</li>
</ol>
<p><strong>Bloom filters:</strong></p>
<ul>
<li>Compact representation of &quot;entries I have&quot;</li>
<li>Low false-positive rate</li>
<li>Efficient sync (don&#39;t re-send known entries)</li>
</ul>
<p><strong>Rate limiting:</strong></p>
<ul>
<li>Per-peer token bucket</li>
<li>Prioritize entries from high-trust peers</li>
<li>Drop announcements under load (fall back to anti-entropy)</li>
</ul>
<hr>
<h3>6.3 Topic Model</h3>
<p><strong>Decision: Scoped gossip channels with ACLs</strong></p>
<p><strong>Topics:</strong></p>
<pre><code class="language-rust">pub struct Topic {
    name: String,              // &quot;global:identity&quot;, &quot;contract:abc123&quot;
    acl: AccessControl,        // Who can publish/subscribe?
    retention: Duration,       // How long to keep entries?
    bloom_filter: BloomFilter, // For anti-entropy
}

pub enum AccessControl {
    Public,                    // Anyone (e.g., identity announcements)
    TrustClass(TrustClass),    // Only Partners+
    Participants(Vec&lt;Did&gt;),    // Contract-specific
}
</code></pre>
<p><strong>Standard topics:</strong></p>
<ul>
<li><code>global:identity</code> - DID announcements, key rotations</li>
<li><code>global:rendezvous</code> - Peer discovery hints</li>
<li><code>contract:{hash}</code> - Per-contract messages</li>
<li><code>ledger:{currency}</code> - Per-currency ledger sync</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>Not everything needs global broadcast</li>
<li>Scoped topics reduce bandwidth</li>
<li>ACLs prevent spam</li>
</ul>
<hr>
<h3>6.4 Bandwidth Management</h3>
<p><strong>Decision: Adaptive rate limiting with QoS</strong></p>
<p><strong>Strategy:</strong></p>
<ol>
<li><strong>Measure available bandwidth</strong> (periodic speed test to trusted peer)</li>
<li><strong>Allocate budgets:</strong><pre><code>Critical (identity, ledger): 40%
High (contracts): 30%
Normal (gossip): 20%
Low (discovery): 10%
</code></pre>
</li>
<li><strong>Drop low-priority under congestion</strong></li>
<li><strong>Backpressure to application</strong> (slow down contract execution if can&#39;t sync)</li>
</ol>
<p><strong>Per-peer limits:</strong></p>
<ul>
<li>Trust-weighted: Federated peers get more bandwidth</li>
<li>Fairness: No single peer starves others</li>
</ul>
<hr>
<h3>6.5 Network Protocol Bridge</h3>
<p><strong>Decision: Length-prefixed bincode over QUIC streams</strong></p>
<p><strong>Protocol:</strong></p>
<p><strong>Wire format:</strong></p>
<pre><code>[4 bytes: length (big-endian)] [N bytes: bincode-serialized NetworkMessage]
</code></pre>
<p><strong>NetworkMessage envelope:</strong></p>
<pre><code class="language-rust">pub struct NetworkMessage {
    version: u32,           // Protocol version (current: 1)
    from: Did,              // Source DID
    to: Option&lt;Did&gt;,        // Destination (None = broadcast)
    payload: MessagePayload,
}

pub enum MessagePayload {
    Gossip(GossipMessage),  // Wrapped gossip protocol
    Ping,                   // Keepalive
    Pong,                   // Response to ping
    Subscribe { topics: Vec&lt;String&gt; },
    Unsubscribe { topics: Vec&lt;String&gt; },
    SubscribeAck { topics: Vec&lt;String&gt; },
}
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Length-prefixed:</strong> Handles variable-size messages efficiently</li>
<li><strong>Bincode:</strong> Fast, compact serialization (5-10% overhead)</li>
<li><strong>DID routing:</strong> Enables unicast and broadcast patterns</li>
<li><strong>Versioned:</strong> Forward compatibility for protocol evolution</li>
<li><strong>Simple:</strong> No complex framing, easy to implement</li>
</ul>
<p><strong>Message flow:</strong></p>
<ol>
<li><p><strong>Publishing:</strong></p>
<pre><code>Ledger â†’ GossipActor.publish() â†’ (in-process only in v1)
</code></pre>
<p><em>Network publishing deferred to Phase 7</em></p>
</li>
<li><p><strong>Reception:</strong></p>
<pre><code>QUIC connection â†’ NetworkActor.handle_incoming_connections()
â†’ read_message() â†’ IncomingMessageHandler callback
â†’ Supervisor extracts GossipMessage
â†’ GossipActor.handle_message() â†’ process/store
</code></pre>
</li>
<li><p><strong>Anti-entropy:</strong></p>
<pre><code>Background task (30s interval)
â†’ NetworkHandle.broadcast(RequestBloomFilter)
â†’ All connected peers receive
â†’ (Response handling deferred to Phase 7)
</code></pre>
</li>
</ol>
<p><strong>Implementation details:</strong></p>
<ul>
<li><p><strong>NetworkActor extensions:</strong></p>
<ul>
<li><code>send_message(did, message)</code>: Unicast to specific peer</li>
<li><code>broadcast(message)</code>: Multicast to all connected peers</li>
<li><code>handle_incoming_connections()</code>: Background acceptor task</li>
<li><code>handle_connection()</code>: Per-connection stream processor</li>
</ul>
</li>
<li><p><strong>Gossip routing:</strong></p>
<ul>
<li>Supervisor creates <code>IncomingMessageHandler</code> callback</li>
<li>Callback extracts <code>GossipMessage</code> from <code>NetworkMessage</code></li>
<li>Routes to <code>GossipActor.handle_message()</code></li>
</ul>
</li>
<li><p><strong>Limitations (v1):</strong></p>
<ul>
<li>Push-only: Can announce entries, cannot request</li>
<li>No request/response correlation</li>
<li>Broadcast-only anti-entropy (O(n) messages)</li>
<li>No topic-based routing</li>
</ul>
</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li>Message overhead: ~100 bytes + payload</li>
<li>Single send latency: 1-2ms (local network)</li>
<li>Broadcast to 10 peers: 10-20ms</li>
<li>Max message size: 10MB</li>
</ul>
<p><strong>Completed in Phase 7:</strong></p>
<ul>
<li>âœ… Complete pull protocol (Request â†’ Response)</li>
<li>âœ… Topic subscriptions (filter by interest)</li>
</ul>
<p><strong>Future enhancements:</strong></p>
<ul>
<li>Smart peer selection (probabilistic gossip)</li>
<li>Message batching (multiple per stream)</li>
</ul>
<hr>
<h3>6.6 Topic Subscriptions</h3>
<p><strong>Decision: Explicit subscription management with ACL enforcement</strong></p>
<p><strong>Implementation:</strong></p>
<p>Topic subscriptions enable peers to express interest in specific topics and receive filtered gossip messages. The subscription system consists of three layers:</p>
<p><strong>1. GossipActor Subscription Management:</strong></p>
<pre><code class="language-rust">impl GossipActor {
    /// Subscribe a DID to a topic (with ACL check)
    pub fn subscribe(&amp;mut self, topic: &amp;str, subscriber: Did) -&gt; Result&lt;Subscription&gt;;

    /// Unsubscribe a DID from a topic
    pub fn unsubscribe(&amp;mut self, topic: &amp;str, subscriber: &amp;Did) -&gt; Result&lt;()&gt;;

    /// Query methods
    pub fn get_subscribers(&amp;self, topic: &amp;str) -&gt; Vec&lt;Did&gt;;
    pub fn get_subscriptions(&amp;self, did: &amp;Did) -&gt; Vec&lt;String&gt;;
    pub fn is_subscribed(&amp;self, topic: &amp;str, did: &amp;Did) -&gt; bool;
}
</code></pre>
<p><strong>2. Network Protocol Messages:</strong></p>
<pre><code class="language-rust">pub enum MessagePayload {
    // Existing...
    Subscribe { topics: Vec&lt;String&gt; },     // Request subscription
    Unsubscribe { topics: Vec&lt;String&gt; },   // Cancel subscription
    SubscribeAck { topics: Vec&lt;String&gt; },  // Confirm subscription
}
</code></pre>
<p><strong>3. Supervisor Message Routing:</strong></p>
<p>The supervisor&#39;s incoming message handler processes subscription messages:</p>
<pre><code>Subscribe received â†’ GossipActor.subscribe() (with ACL check)
                  â†’ Send SubscribeAck for successful subscriptions

Unsubscribe received â†’ GossipActor.unsubscribe()
</code></pre>
<p><strong>Subscription Flow:</strong></p>
<ol>
<li><p><strong>Node A wants to subscribe to &quot;global:identity&quot; on Node B:</strong></p>
<pre><code>Node A â†’ Send Subscribe {topics: [&quot;global:identity&quot;]} â†’ Node B
Node B â†’ Check ACL via trust_lookup(Node A)
Node B â†’ Add Node A to subscribers if authorized
Node B â†’ Send SubscribeAck {topics: [&quot;global:identity&quot;]} â†’ Node A
</code></pre>
</li>
<li><p><strong>ACL Enforcement:</strong></p>
<ul>
<li>Subscriptions are checked against topic AccessControl rules</li>
<li>TrustClass-gated topics require minimum trust level</li>
<li>Participants-only topics enforce whitelist</li>
<li>Public topics allow all subscriptions</li>
</ul>
</li>
<li><p><strong>Subscription State:</strong></p>
<ul>
<li>In-memory HashMap: <code>topic â†’ Vec&lt;subscriber_did&gt;</code></li>
<li>Not persisted (resubscribe on reconnection)</li>
<li>Metrics tracked: <code>icn_gossip_subscriptions_total</code></li>
</ul>
</li>
</ol>
<p><strong>Metrics:</strong></p>
<pre><code>icn_gossip_subscriptions_total          # Gauge: Total active subscriptions
icn_gossip_subscribes_received_total    # Counter: Subscribe messages received
icn_gossip_unsubscribes_received_total  # Counter: Unsubscribe messages received
icn_gossip_subscribe_acks_sent_total    # Counter: SubscribeAck messages sent
</code></pre>
<p><strong>Limitations (v1):</strong></p>
<ul>
<li>No persistence (subscriptions lost on restart)</li>
<li>No automatic resubscription protocol</li>
<li>Broadcast still sends to all peers (subscription doesn&#39;t filter routing yet)</li>
<li>No subscription metadata (timestamp, filters, preferences)</li>
</ul>
<p><strong>Future enhancements:</strong></p>
<ul>
<li>Selective routing based on subscriptions (bandwidth optimization)</li>
<li>Subscription persistence and reconnection recovery</li>
<li>Topic filters (e.g., subscribe to &quot;ledger:*&quot; pattern)</li>
<li>Per-subscription metadata and preferences</li>
</ul>
<hr>
<h2>7. Data Storage</h2>
<p>Persistent storage anchors all ephemeral network state: identities, trust edges, ledger entries, contracts, and task queues. The pluggable storage trait enables evolution from embedded databases to distributed backends.</p>
<h3>7.1 Storage Backend</h3>
<p><strong>Decision: Pluggable trait with Sled default (v1)</strong></p>
<p><strong>Trait:</strong></p>
<pre><code class="language-rust">pub trait Store: Send + Sync {
    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
    fn put(&amp;self, key: &amp;[u8], value: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn delete(&amp;self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn scan(&amp;self, prefix: &amp;[u8]) -&gt; Result&lt;Vec&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;;
    fn batch_write(&amp;self, ops: Vec&lt;WriteOp&gt;) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p><strong>Implementations:</strong></p>
<ul>
<li><strong>Sled</strong> (v1): Embedded, pure Rust, transactional</li>
<li><strong>RocksDB</strong> (v2): More mature, faster, C++ dependency</li>
<li><strong>SQLite</strong> (future): If we need relational queries</li>
</ul>
<p><strong>Namespaces:</strong></p>
<pre><code>identity/
  keypair           # Encrypted key
  rotations/        # Key rotation history

trust/
  edges/            # Trust graph edges
  evidence/         # Evidence records

ledger/
  journal/          # All entries (content-addressed)
  balances/         # Cached balances per account
  checkpoints/      # Merkle roots

contracts/
  installed/        # Contract code
  state/            # Contract storage

peers/
  known/            # Discovered peers
  sessions/         # Active connections

config/
  node              # Node config
</code></pre>
<hr>
<h3>7.2 Schema Evolution</h3>
<p><strong>Decision: Versioned schemas with migration path</strong></p>
<p><strong>Approach:</strong></p>
<pre><code class="language-rust">pub struct SchemaVersion {
    version: u32,
    migrate: fn(&amp;Store) -&gt; Result&lt;()&gt;,
}

// On startup:
fn ensure_schema() {
    let current = store.get(b&quot;schema/version&quot;)?;
    match current {
        Some(v) if v == LATEST_VERSION =&gt; return Ok(()),
        Some(v) =&gt; run_migrations(v, LATEST_VERSION)?,
        None =&gt; initialize_schema()?,
    }
}
</code></pre>
<p><strong>Migration strategy:</strong></p>
<ul>
<li>Backward-compatible when possible</li>
<li>Breaking changes: copy data to new namespace</li>
<li>Keep old data until migration verified</li>
</ul>
<p><strong>Backup before migration:</strong></p>
<pre><code class="language-bash">icnctl backup create pre-migration-v2
</code></pre>
<hr>
<h3>7.3 Pruning &amp; Archival</h3>
<p><strong>Decision: Configurable retention with archive export</strong></p>
<p><strong>Retention policies:</strong></p>
<pre><code class="language-rust">pub struct RetentionPolicy {
    keep_last_entries: usize,     // e.g., 10,000
    keep_duration: Duration,      // e.g., 1 year
    archive_path: Option&lt;PathBuf&gt;,
}
</code></pre>
<p><strong>What to prune:</strong></p>
<ul>
<li>Old journal entries (keep Merkle roots)</li>
<li>Expired trust edges</li>
<li>Revoked contracts</li>
</ul>
<p><strong>What to keep:</strong></p>
<ul>
<li>Active account balances</li>
<li>Current contract state</li>
<li>Recent entries (within retention window)</li>
</ul>
<p><strong>Archive format:</strong></p>
<ul>
<li>JSON-LD for interop</li>
<li>Signed by node (provenance)</li>
<li>Can re-import if needed</li>
</ul>
<hr>
<h3>7.4 Data Durability &amp; Replication</h3>
<p><strong>Decision: Trust-weighted automatic replication (Phase 17)</strong></p>
<p><strong>Current State (v1): Gossip-based implicit replication</strong></p>
<p>ICN v1 relies on gossip protocol for data distribution with social redundancy:</p>
<ul>
<li><strong>Ledger entries</strong>: Replicated to all participants in currency/contract</li>
<li><strong>Contracts</strong>: Replicated to all signatories</li>
<li><strong>Compute tasks</strong>: Ephemeral, replicated to interested executors</li>
<li><strong>Trust edges</strong>: Local-only (subjective, not replicated)</li>
<li><strong>Identity keys</strong>: User-managed backups (never replicated for security)</li>
</ul>
<p><strong>Durability by Data Type:</strong></p>
<table>
<thead>
<tr>
<th>Data Type</th>
<th>Current Replication</th>
<th>Durability</th>
<th>Recovery Mechanism</th>
</tr>
</thead>
<tbody><tr>
<td>Ledger entries</td>
<td>All participants (social)</td>
<td>High</td>
<td>Re-sync from any participant</td>
</tr>
<tr>
<td>Contracts</td>
<td>All participants</td>
<td>High</td>
<td>Re-deploy from source</td>
</tr>
<tr>
<td>Trust edges</td>
<td>Single node</td>
<td>Low</td>
<td>Manual backup/restore</td>
</tr>
<tr>
<td>Identity keys</td>
<td>User backups only</td>
<td>User responsibility</td>
<td>Restore from <code>icnctl backup</code></td>
</tr>
<tr>
<td>Compute tasks</td>
<td>Subscribed executors</td>
<td>Medium</td>
<td>Timeout and retry</td>
</tr>
<tr>
<td>Compute results</td>
<td>Submitter + witnesses</td>
<td>Medium</td>
<td>Re-execute if lost</td>
</tr>
</tbody></table>
<p><strong>Failure Modes:</strong></p>
<ul>
<li><strong>Single node failure</strong>: No data loss if other participants exist</li>
<li><strong>Network partition</strong>: Nodes continue operating, re-sync when partition heals via anti-entropy</li>
<li><strong>Simultaneous failure of all participants</strong>: Data loss (requires external backup)</li>
<li><strong>Disk corruption</strong>: Manual restore from backup + re-sync from peers</li>
</ul>
<hr>
<p><strong>Phase 17: Explicit Replication Management</strong></p>
<p><strong>Architecture:</strong></p>
<pre><code class="language-rust">pub struct ReplicationPolicy {
    data_type: DataType,
    min_replicas: usize,        // Hard minimum (alert if below)
    target_replicas: usize,     // Soft target (continuous optimization)
    strategy: ReplicationStrategy,
}

pub enum ReplicationStrategy {
    TrustWeighted { min_trust: f64 },           // Replicate to high-trust peers
    Participants { dids: Vec&lt;Did&gt; },            // Contract/ledger participants
    GeoDiverse { regions: Vec&lt;String&gt; },        // Regional spread for resilience
    Hybrid(Vec&lt;ReplicationStrategy&gt;),           // Combine strategies
}

pub enum DataType {
    LedgerEntry,      // Critical: all participants + 3 trusted peers
    Contract,         // Critical: all participants + 2 trusted peers
    TrustEdge,        // Personal: local + 2 high-trust backups
    ComputeTask,      // Ephemeral: 2 executors (temporary)
    ComputeResult,    // Important: submitter + 2 trusted peers
}
</code></pre>
<p><strong>ReplicationManager Actor:</strong></p>
<p>Monitors replication health and triggers re-replication when needed:</p>
<ol>
<li><p><strong>Periodic Health Check</strong> (every 60s):</p>
<ul>
<li>Scan all stored content</li>
<li>Check current replica count vs. policy</li>
<li>Trigger re-replication if below <code>min_replicas</code></li>
</ul>
</li>
<li><p><strong>Replica Selection</strong>:</p>
<ul>
<li>Query trust graph for candidates</li>
<li>Filter by trust threshold and strategy</li>
<li>Prefer peers with available capacity</li>
</ul>
</li>
<li><p><strong>Replication Protocol</strong>:</p>
<pre><code>Under-replicated data detected
â†’ Select N new replica holders (trust-weighted)
â†’ Send ReplicaRequest via gossip
â†’ Peer accepts â†’ transfers data
â†’ Update metadata â†’ increment replica count
</code></pre>
</li>
<li><p><strong>Metrics</strong>:</p>
<ul>
<li><code>icn_data_replicas{data_type, hash}</code> - Current count</li>
<li><code>icn_data_under_replicated_total</code> - Alert trigger</li>
<li><code>icn_replication_requests_sent_total</code></li>
<li><code>icn_replication_duration_seconds</code></li>
</ul>
</li>
</ol>
<p><strong>Default Policies:</strong></p>
<pre><code class="language-rust">// Ledger entries: Critical financial data
ReplicationPolicy {
    data_type: LedgerEntry,
    min_replicas: 3,        // Participants + 3 trusted backups
    target_replicas: 5,
    strategy: Hybrid([
        Participants { dids },
        TrustWeighted { min_trust: 0.4 },
    ]),
}

// Contracts: Critical code + state
ReplicationPolicy {
    data_type: Contract,
    min_replicas: 2,        // Participants + 2 backups
    target_replicas: 4,
    strategy: Participants { dids },
}

// Trust edges: Personal relationship data
ReplicationPolicy {
    data_type: TrustEdge,
    min_replicas: 2,        // Local + 2 high-trust peers
    target_replicas: 3,
    strategy: TrustWeighted { min_trust: 0.7 },
}
</code></pre>
<p><strong>Configuration:</strong></p>
<pre><code class="language-toml">[storage.replication]
enabled = true
check_interval_seconds = 60

[storage.replication.ledger]
min_replicas = 3
target_replicas = 5
strategy = &quot;trust_weighted&quot;
min_trust = 0.4

[storage.replication.contracts]
min_replicas = 2
target_replicas = 4
strategy = &quot;participants&quot;

[storage.replication.trust_edges]
min_replicas = 2
target_replicas = 3
strategy = &quot;trust_weighted&quot;
min_trust = 0.7
</code></pre>
<p><strong>Gossip Protocol Extensions:</strong></p>
<pre><code class="language-rust">pub enum GossipMessage {
    // ... existing messages

    ReplicaRequest {
        content_hash: ContentHash,
        requester: Did,
        reason: ReplicationReason,
    },

    ReplicaOffer {
        content_hash: ContentHash,
        holder: Did,
        replica_count: usize,
    },

    ReplicaStatus {
        content_hash: ContentHash,
        replicas: Vec&lt;ReplicaInfo&gt;,
    },
}

pub enum ReplicationReason {
    UnderReplicated,    // Below min_replicas
    PeerLeaving,        // Node announced shutdown
    TrustDegraded,      // Replica holder&#39;s trust dropped
    GeoDiversity,       // Need regional spread
}
</code></pre>
<p><strong>Storage Layer Extensions:</strong></p>
<pre><code class="language-rust">pub trait Store: Send + Sync {
    // ... existing methods

    // Replication tracking
    fn get_replica_count(&amp;self, hash: &amp;ContentHash) -&gt; Result&lt;usize&gt;;
    fn get_replica_holders(&amp;self, hash: &amp;ContentHash) -&gt; Result&lt;Vec&lt;Did&gt;&gt;;
    fn mark_replica(&amp;self, hash: &amp;ContentHash, holder: &amp;Did) -&gt; Result&lt;()&gt;;
    fn remove_replica(&amp;self, hash: &amp;ContentHash, holder: &amp;Did) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p><strong>Implementation Timeline:</strong></p>
<p>Phase 17 will be implemented in 4 weeks:</p>
<ul>
<li><strong>Week 1</strong>: Storage layer extensions (replica tracking metadata)</li>
<li><strong>Week 2</strong>: Gossip protocol extensions (ReplicaRequest/Offer/Status)</li>
<li><strong>Week 3</strong>: ReplicationManager actor (monitoring + selection)</li>
<li><strong>Week 4</strong>: Integration testing (failure scenarios, performance)</li>
</ul>
<p><strong>Critical Test Scenarios:</strong></p>
<pre><code class="language-rust">// Automatic replication on node join
#[tokio::test]
async fn test_new_node_receives_replicas() {
    // 1. Start 2 nodes with critical data
    // 2. Third node joins with high trust
    // 3. Verify ReplicationManager replicates to new node
}

// Re-replication after node failure
#[tokio::test]
async fn test_replication_after_failure() {
    // 1. Start 5 nodes, min_replicas=3, data on all 5
    // 2. Kill 2 nodes
    // 3. Verify manager detects under-replication
    // 4. Verify new replicas created within 2 minutes
}

// Trust degradation triggers replacement
#[tokio::test]
async fn test_trust_degradation_replacement() {
    // 1. Data replicated to high-trust peers
    // 2. One peer&#39;s trust drops below threshold
    // 3. Verify manager selects replacement replica holder
}
</code></pre>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li>âœ… <strong>Prevents data loss</strong> from node failures</li>
<li>âœ… <strong>Automatic</strong> (no manual intervention)</li>
<li>âœ… <strong>Trust-aware</strong> (replicate to reliable peers)</li>
<li>âœ… <strong>Configurable</strong> (per-data-type policies)</li>
<li>âŒ <strong>Storage overhead</strong> (3-5x vs single copy)</li>
<li>âŒ <strong>Bandwidth cost</strong> (replication traffic)</li>
<li>âŒ <strong>Complexity</strong> (monitoring, selection logic)</li>
</ul>
<p><strong>Future Enhancements:</strong></p>
<ul>
<li><strong>Erasure coding</strong> for bulk data (1.5x storage vs 3x)</li>
<li><strong>Geo-aware placement</strong> (regional compliance, latency optimization)</li>
<li><strong>Economic incentives</strong> (pay peers in credits to store replicas)</li>
<li><strong>Pinning API</strong> (<code>icnctl pin &lt;hash&gt;</code> to guarantee persistence)</li>
</ul>
<hr>
<h2>8. Security Model</h2>
<p>Security in ICN is defense-in-depth: cryptographic primitives, trust-based access control, resource limits, and operational hardening work together to resist attacks while preserving decentralization.</p>
<p><strong>Security Guarantees (v1):</strong></p>
<ul>
<li><strong>Authenticity</strong>: Ed25519 signatures on all messages, ledger entries, and compute results</li>
<li><strong>Integrity</strong>: Merkle-DAG ledger structure prevents tampering; signature chains prevent forgery</li>
<li><strong>Sybil resistance</strong>: Trust graph gatekeeping prevents identity farming attacks</li>
<li><strong>DoS protection</strong>: Rate limiting + trust-gated access + fuel metering prevent resource exhaustion</li>
<li><strong>Privacy</strong>: Semi-private ledger with selective disclosure; optional auditor roles</li>
<li><strong>Resilience</strong>: Gossip-based divergence recovery; no single point of failure</li>
</ul>
<h3>8.1 Threat Model</h3>
<p><strong>Assumptions:</strong></p>
<ul>
<li><p><strong>Adversary can:</strong></p>
<ul>
<li>Create unlimited Sybil identities (but no initial trust)</li>
<li>Control network (MITM, partition, delay)</li>
<li>Compromise individual nodes</li>
<li>Collude with other adversaries</li>
</ul>
</li>
<li><p><strong>Adversary cannot:</strong></p>
<ul>
<li>Break Ed25519 cryptography</li>
<li>Forge signatures</li>
<li>Compromise all nodes simultaneously</li>
</ul>
</li>
</ul>
<p><strong>Out of scope (v1):</strong></p>
<ul>
<li>Quantum attacks (post-quantum crypto in v2)</li>
<li>Side-channel attacks (constant-time crypto)</li>
<li>Physical access (rely on OS security)</li>
</ul>
<hr>
<h3>8.2 Attack Surface</h3>
<p><strong>External:</strong></p>
<ul>
<li>Network (QUIC/TLS) - mitigated by mutual auth, rate limits</li>
<li>RPC (gRPC) - mitigated by auth, capability checks</li>
<li>Discovery (mDNS, rendezvous) - mitigated by verification</li>
</ul>
<p><strong>Internal:</strong></p>
<ul>
<li>Contract execution - mitigated by sandboxing, fuel limits</li>
<li>Ledger sync - mitigated by signature checks, invariants</li>
<li>Storage - mitigated by encryption at rest</li>
</ul>
<p><strong>Supply chain:</strong></p>
<ul>
<li>Dependencies - use <code>cargo audit</code>, lock file</li>
<li>Build - reproducible builds (future)</li>
<li>Distribution - signed releases (cosign)</li>
</ul>
<hr>
<h3>8.3 Incident Response</h3>
<p><strong>Process:</strong></p>
<ol>
<li><strong>Detect:</strong> Monitoring alerts (unusual trust changes, ledger anomalies)</li>
<li><strong>Contain:</strong> Quarantine affected entries, disconnect malicious peers</li>
<li><strong>Analyze:</strong> Review logs, ledger history</li>
<li><strong>Remediate:</strong> Deploy fix, coordinate with network</li>
<li><strong>Disclose:</strong> Public postmortem (if not exploitable)</li>
</ol>
<p><strong>Security contacts:</strong></p>
<ul>
<li><a href="https://github.com/InterCooperative-Network/icn/blob/main/mailto:security@intercooperative.network">security@intercooperative.network</a> (to be set up)</li>
<li>Encrypted reporting (PGP)</li>
</ul>
<hr>
<h3>8.4 Production Hardening</h3>
<p>ICN implements comprehensive DoS protection and resource management:</p>
<p><strong>Network-level protections:</strong></p>
<ul>
<li><strong>Rate limiting:</strong> Token bucket per-peer (100 msg/sec, burst 20)<ul>
<li>Implementation: <code>icn-net/src/rate_limit.rs</code></li>
<li>Metric: <code>icn_network_messages_rate_limited_total</code></li>
</ul>
</li>
<li><strong>QUIC stream limits:</strong> 10 concurrent streams, 1MB/stream window<ul>
<li>Prevents stream flooding attacks</li>
<li>Connection idle timeout: 60s, keep-alive: 30s</li>
</ul>
</li>
<li><strong>Message size validation:</strong> 10MB max, validated before allocation<ul>
<li>Prevents unbounded memory allocation DoS</li>
</ul>
</li>
</ul>
<p><strong>Protocol-level protections:</strong></p>
<ul>
<li><strong>Certificate validation:</strong> DID extraction + expiration checks<ul>
<li>TLS verifier validates DID format and validity period</li>
<li>âš ï¸ Trust graph integration pending (accepts all valid DIDs)</li>
</ul>
</li>
<li><strong>Bloom filter validation:</strong> Bounds checking on deserialization<ul>
<li>Handles zero-size and malformed filter data safely</li>
</ul>
</li>
<li><strong>Timestamp overflow protection:</strong> Checked conversion u128 â†’ u64<ul>
<li>Prevents silent wraparound post-year 2262</li>
</ul>
</li>
</ul>
<p><strong>Runtime protections:</strong></p>
<ul>
<li><strong>Async-safe operations:</strong> No <code>blocking_*</code> calls in Tokio runtime<ul>
<li>All message handlers spawn async tasks</li>
<li>Prevents thread pool starvation</li>
</ul>
</li>
</ul>
<p><strong>See also:</strong> <a href="https://github.com/InterCooperative-Network/icn/blob/main/docs/security/production-hardening">Production Hardening Documentation</a> for detailed implementation notes, configuration, and monitoring recommendations.</p>
<hr>
<h2>9. Performance &amp; Scalability</h2>
<p>ICN targets cooperative-scale deployments (100s-1000s of nodes), optimizing for interactive UX and reasonable throughput rather than high-frequency trading or global-scale consensus.</p>
<h3>9.1 Target Metrics (v1)</h3>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Target</th>
<th>Rationale</th>
</tr>
</thead>
<tbody><tr>
<td>Ledger write latency</td>
<td>&lt;100ms</td>
<td>Interactive UX</td>
</tr>
<tr>
<td>Ledger sync latency</td>
<td>&lt;1s (LAN), &lt;5s (WAN)</td>
<td>Reasonable propagation</td>
</tr>
<tr>
<td>Contract execution</td>
<td>&lt;50ms</td>
<td>Keep UI responsive</td>
</tr>
<tr>
<td>Peer connections</td>
<td>500 concurrent</td>
<td>Medium-sized cooperative</td>
</tr>
<tr>
<td>Throughput</td>
<td>100 tx/sec per node</td>
<td>Not high-frequency trading</td>
</tr>
</tbody></table>
<p><strong>Not optimizing for:</strong></p>
<ul>
<li>Millions of nodes (v1 is cooperative-scale: 100s-1000s)</li>
<li>High-frequency trading (use CEX)</li>
<li>Massive contracts (keep contracts focused)</li>
</ul>
<hr>
<h3>9.2 Bottlenecks</h3>
<p><strong>Known:</strong></p>
<ul>
<li>Signature verification (CPU-bound) - mitigate with batching</li>
<li>Ledger sync (network-bound) - mitigate with compression</li>
<li>Contract execution (interpreter overhead) - v2: WASM is faster</li>
</ul>
<p><strong>Monitoring:</strong></p>
<ul>
<li>Prometheus metrics</li>
<li>Distributed tracing (OpenTelemetry)</li>
<li>Profiling (perf, flamegraph)</li>
</ul>
<hr>
<h3>9.3 Scaling Strategy</h3>
<p><strong>Vertical:</strong></p>
<ul>
<li>Better hardware (more cores, faster disk)</li>
<li>Tuning (tokio threads, buffer sizes)</li>
</ul>
<p><strong>Horizontal:</strong></p>
<ul>
<li>Sharding (per-contract nodes)</li>
<li>Specialized nodes (relay, rendezvous, archival)</li>
</ul>
<p><strong>Not:</strong></p>
<ul>
<li>Global sharding (breaks local-first model)</li>
<li>Consensus (kills availability)</li>
</ul>
<hr>
<h2>10. Operational Considerations</h2>
<p>Running ICN in production requires packaging, monitoring, backup procedures, and upgrade coordination. This section covers deployment patterns and operational best practices.</p>
<h3>10.1 Deployment</h3>
<p><strong>Platforms:</strong></p>
<ul>
<li><strong>Linux</strong> (primary): systemd service, Docker</li>
<li><strong>macOS</strong> (dev): launchd, native binary</li>
<li><strong>Windows</strong> (future): Windows Service, WSL2</li>
</ul>
<p><strong>Packaging:</strong></p>
<ul>
<li>Debian/Ubuntu: .deb</li>
<li>Fedora/RHEL: .rpm</li>
<li>Arch: AUR package</li>
<li>Nix: flake (deterministic)</li>
</ul>
<p><strong>Docker:</strong></p>
<pre><code class="language-dockerfile">FROM rust:1.75 AS builder
# Build...

FROM debian:bookworm-slim
COPY --from=builder /app/icnd /usr/local/bin/
ENTRYPOINT [&quot;icnd&quot;]
</code></pre>
<hr>
<h3>10.2 Configuration</h3>
<p><strong>Config file:</strong> <code>--config /path/to/config.toml</code> (or runtime defaults when omitted)</p>
<p><strong>Example configuration:</strong></p>
<pre><code class="language-toml">data_dir = &quot;/var/lib/icn&quot;

[network]
listen_addr = &quot;0.0.0.0:7777&quot;

[compute]
enabled = true

[compute.trust]
min_trust_submit = 0.1     # Minimum trust to submit tasks
min_trust_execute = 0.3    # Minimum trust to execute tasks

[compute.resources]
max_concurrent_tasks = 10
cpu_cores = 8
ram_gb = 16
gpu_units = 0

[gateway]
enabled = false
bind_addr = &quot;127.0.0.1:8080&quot;
jwt_secret = &quot;your-secret-here&quot;
token_expiry_hours = 24
</code></pre>
<p><strong>Runtime overrides:</strong></p>
<ul>
<li><code>--data-dir</code> and <code>--log-level</code> CLI flags</li>
<li><code>ICN_GATEWAY_JWT_SECRET</code> for gateway JWT secret</li>
</ul>
<p><strong>Trust thresholds:</strong></p>
<p>The <code>min_trust_submit</code> and <code>min_trust_execute</code> values gate access to the compute layer:</p>
<ul>
<li><code>min_trust_submit = 0.1</code> - Members with trust score &gt;= 0.1 can submit tasks (Known tier)</li>
<li><code>min_trust_execute = 0.3</code> - Executors with trust score &gt;= 0.3 can claim tasks (Partner tier)</li>
</ul>
<p>These defaults balance accessibility (low barrier for task submission) with security (higher barrier for code execution).</p>
<hr>
<h3>10.3 Monitoring</h3>
<p><strong>Observability stack:</strong></p>
<ul>
<li><strong>Logs:</strong> Structured (JSON) to stdout, rotate with logrotate</li>
<li><strong>Metrics:</strong> Prometheus exporter on <code>:9100/metrics</code></li>
<li><strong>Tracing:</strong> OpenTelemetry (optional export to Jaeger)</li>
<li><strong>Health:</strong> <code>/healthz</code> endpoint (OK/DEGRADED)</li>
</ul>
<p><strong>Key metrics:</strong></p>
<pre><code>icn_peers_connected{trust_class}
icn_ledger_entries_total
icn_ledger_sync_latency_seconds
icn_contract_executions_total{status}
icn_trust_score_changes_total
</code></pre>
<p><strong>Alerting:</strong></p>
<ul>
<li>No peers connected (isolation)</li>
<li>Ledger sync stalled</li>
<li>Disk space low</li>
<li>High error rate</li>
</ul>
<hr>
<h3>10.4 Backup &amp; Disaster Recovery</h3>
<p><strong>Backup:</strong></p>
<pre><code class="language-bash">icnctl backup create --output backup-$(date +%Y%m%d).tar.gz
</code></pre>
<p><strong>Contents:</strong></p>
<ul>
<li>Identity keys (encrypted)</li>
<li>Ledger (all entries)</li>
<li>Contract state</li>
<li>Trust graph</li>
<li>Config</li>
</ul>
<p><strong>Restore:</strong></p>
<pre><code class="language-bash">icnctl backup restore backup-20251110.tar.gz
</code></pre>
<p><strong>Disaster recovery:</strong></p>
<ul>
<li>Identity key lost â†’ use recovery key (created at setup)</li>
<li>Ledger corrupted â†’ restore from backup + re-sync</li>
<li>Node destroyed â†’ restore on new machine, peers recognize DID</li>
</ul>
<hr>
<h3>10.5 Upgrades</h3>
<p><strong>Process:</strong></p>
<ol>
<li>Release new version (GitHub releases)</li>
<li>Announce in community channels</li>
<li>Node operators pull new binary</li>
<li>Restart daemon (graceful shutdown)</li>
<li>Migration runs on startup (if needed)</li>
</ol>
<p><strong>Backward compatibility:</strong></p>
<ul>
<li>Protocol versioned (peers negotiate)</li>
<li>Old nodes can talk to new nodes (within major version)</li>
</ul>
<p><strong>Breaking changes:</strong></p>
<ul>
<li>Major version bump</li>
<li>Coordination period (e.g., &quot;upgrade by Jan 1&quot;)</li>
</ul>
<hr>
<h2>11. Distributed Compute Layer</h2>
<p><strong>Status:</strong> Phase 16E Complete (2025-11-24)
<strong>Introduced:</strong> Phase 15 (2025-11-21)
<strong>Evolution:</strong> Phase 16A-E (2025-11-23 to 2025-11-24)</p>
<p><strong>Mental Model:</strong></p>
<p>Think of ICN&#39;s compute layer as a <strong>federated job board</strong> combined with a <strong>cooperative cluster scheduler</strong>. Members post tasks to the network via gossip (like pinning a job listing on a community board). Executors browse available work, claim tasks based on their capabilities and trust relationships, execute them locally using the CCL interpreter, and get paid automatically via the mutual credit ledger. Unlike centralized schedulers (Kubernetes) or blockchain VMs (Ethereum), there&#39;s no central coordinatorâ€”just peers cooperating through social trust and economic incentives. Policies are democratic: cooperatives vote on rules (GDPR compliance, time windows, resource quotas) via governance proposals, and the network enforces them automatically.</p>
<p>The distributed compute layer turns the ICN substrate into a cooperative, trust-aware scheduling fabric for secure job execution, resource sharing, and cross-community workflows.</p>
<p>It enables cooperative task execution across ICN nodes, with trust-gated access, intelligent scheduling, and democratic policy management.</p>
<hr>
<h3>11.1 Core Architecture</h3>
<p><strong>Decision: Actor-based compute model with gossip coordination</strong></p>
<p><strong>Core Types:</strong></p>
<pre><code class="language-rust">// Task priority levels (controls scheduling preference)
pub enum TaskPriority {
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3,
}

// Actor types (controls migration behavior)
pub enum ActorType {
    Stateless,   // No state; 0-RTT migration
    Stateful,    // In-memory state; checkpoint required
    Persistent,  // Durable state; checkpoint + storage sync
}
</code></pre>
<p><strong>Components:</strong></p>
<pre><code>ComputeActor
â”œâ”€â”€ TaskManager       # Task lifecycle (Pending â†’ Claimed â†’ Completed)
â”œâ”€â”€ Executor          # CCL/WASM execution engine
â”œâ”€â”€ PolicyManager     # Cooperative scheduling policies (Phase 16E)
â”œâ”€â”€ MigrationManager  # Stateful actor migration (Phase 16D)
â””â”€â”€ Scheduler         # Multi-factor placement scoring (Phase 16A-C)
</code></pre>
<p><strong>Message Flow:</strong></p>
<pre><code>Submitter â†’ compute:submit â†’ TaskManager (pending)
                                    â†“
         Executor observes â†’ compute:claim â†’ TaskManager (claimed)
                                    â†“
                            Executes CCL
                                    â†“
                    compute:result â†’ Signed result
                                    â†“
                          Payment â†’ Ledger
</code></pre>
<p><strong>Gossip Topics:</strong></p>
<ul>
<li><code>compute:submit</code> - Task submission announcements</li>
<li><code>compute:claim</code> - Executor claim notifications</li>
<li><code>compute:result</code> - Execution results with Ed25519 signatures</li>
<li><code>compute:cancel</code> - Task cancellation requests (submitter-only)</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Actor-based:</strong> Natural fit for distributed task execution</li>
<li><strong>Gossip coordination:</strong> No central scheduler, peer-to-peer task discovery</li>
<li><strong>Trust-gated:</strong> MIN_TRUST_SUBMIT (0.1), MIN_TRUST_EXECUTE (0.3)</li>
<li><strong>Payment settlement:</strong> Automatic compensation via mutual credit ledger</li>
</ul>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li>âœ… Decentralized, no coordinator bottleneck</li>
<li>âœ… Democratic governance over policies</li>
<li>âœ… Trust-based access control</li>
<li>âŒ No global task queue (by design)</li>
<li>âŒ Eventual consistency for task discovery</li>
</ul>
<hr>
<h3>11.2 Scheduler Evolution (Phase 16A-E)</h3>
<h4>11.2.1 Phase 16A: Resource-Aware Placement</h4>
<p><strong>Decision: Resource constraint enforcement at claim time</strong></p>
<p><strong>Implementation:</strong></p>
<ul>
<li>Executors advertise capacities (CPU cores, RAM GB, GPU units)</li>
<li>Tasks specify requirements via ResourceRequirements struct</li>
<li>Scheduler enforces: <code>available_capacity &gt;= task_requirements</code></li>
<li>Placement scoring: <code>capacity_score = min(cpu_fit, ram_fit, gpu_fit)</code></li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>Prevents oversubscription</li>
<li>Enables heterogeneous executor pools</li>
<li>Clear failure modes (capacity rejections logged)</li>
</ul>
<hr>
<h4>11.2.2 Phase 16B: Intelligent Scoring</h4>
<p><strong>Decision: Multi-factor placement algorithm</strong></p>
<p><strong>Scoring Formula:</strong></p>
<pre><code class="language-rust">total_score =
    (0.3 Ã— trust_score) +
    (0.3 Ã— capacity_score) +
    (0.2 Ã— network_score) +    // Phase 16C
    (0.2 Ã— locality_score)      // Phase 16C
</code></pre>
<p><strong>Trust Score:</strong></p>
<ul>
<li>Direct trust graph lookup</li>
<li>Range: 0.0 (unknown) to 1.0 (partner)</li>
<li>Prevents task placement on untrusted executors</li>
</ul>
<p><strong>Capacity Score:</strong></p>
<ul>
<li>Based on resource fit (CPU/RAM/GPU)</li>
<li>Normalized: 1.0 = exact match, 0.5 = 2x overprovisioned</li>
</ul>
<p><strong>Network Score (Phase 16C):</strong></p>
<ul>
<li>Round-trip time (RTT) to executor</li>
<li>Topology awareness (same cluster &gt; same datacenter &gt; remote)</li>
</ul>
<p><strong>Locality Score (Phase 16C):</strong></p>
<ul>
<li>Data proximity (blob announcements)</li>
<li>Reduces data transfer overhead</li>
</ul>
<p><strong>Benchmarked Performance:</strong></p>
<ul>
<li>Intelligent scoring: 50% faster task completion vs random placement</li>
<li>Network-aware: 30% reduction in data transfer latency</li>
<li>Locality-aware: 40% fewer blob fetches</li>
</ul>
<hr>
<h4>11.2.3 Phase 16C: Network &amp; Data Locality</h4>
<p><strong>Decision: Topology-aware scheduling with data proximity</strong></p>
<p><strong>Topology Awareness:</strong></p>
<pre><code class="language-rust">pub enum NetworkZone {
    Local,           // Same node (loopback)
    SameCluster,     // &lt;5ms RTT
    SameDatacenter,  // &lt;20ms RTT
    Remote,          // &gt;20ms RTT
}
</code></pre>
<p><strong>Data Locality:</strong></p>
<ul>
<li>Blob announcement protocol: Executors publish available blobs</li>
<li>Scheduler tracks blob locations per executor</li>
<li>Placement preference: executors with task input blobs</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>TopologyManager</code>: Maintains RTT measurements per peer</li>
<li><code>BlobLocationTracker</code>: Subscribes to <code>blob:announce</code> gossip topic</li>
<li>Scheduler queries both for placement decisions</li>
</ul>
<p><strong>Measured Impact:</strong></p>
<ul>
<li>Same-cluster preference: 45% improvement in task start time</li>
<li>Data locality: 40% reduction in blob transfer overhead</li>
</ul>
<hr>
<h4>11.2.4 Phase 16D: Stateful Actor Migration</h4>
<p><strong>Decision: Checkpoint-based migration for fault tolerance</strong></p>
<p><strong>Migration Protocol:</strong></p>
<pre><code>1. Actor checkpoints state to durable storage
2. MigrationOffer broadcast via gossip
3. Executors respond with bids (capacity, proximity)
4. Originator selects best executor
5. State transfer via NetworkActor
6. New executor restores from checkpoint
7. MigrationComplete broadcast
</code></pre>
<p><strong>Checkpoint Format:</strong></p>
<pre><code class="language-rust">pub struct ActorCheckpoint {
    actor_id: String,
    actor_type: ActorType,  // Stateless, Stateful, Persistent
    state_blob: Vec&lt;u8&gt;,    // Serialized actor state
    sequence: u64,          // Monotonic checkpoint sequence
    dependencies: Vec&lt;String&gt;,  // Required resources/actors
}
</code></pre>
<p><strong>Migration Operational Guarantees:</strong></p>
<ul>
<li><strong>Stateless actors:</strong> No checkpoint required; can migrate instantly (0-RTT restart on new executor)</li>
<li><strong>Stateful actors:</strong> Checkpoint required; migration completes within 2Ã— average task duration</li>
<li><strong>Persistent actors:</strong> Checkpoint + durable storage sync; migration may pause execution briefly (&lt;5s)</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>Enables long-running stateful computations</li>
<li>Survives executor crashes or planned migrations</li>
<li>Supports heterogeneous executor capabilities</li>
</ul>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li>âœ… Fault tolerance for stateful workflows</li>
<li>âœ… Planned maintenance (migrate before shutdown)</li>
<li>âŒ Checkpoint overhead (mitigated with incremental checkpoints)</li>
<li>âŒ State transfer latency (acceptable for long-running tasks)</li>
</ul>
<hr>
<h3>11.3 Cooperative Scheduling Policies (Phase 16E)</h3>
<p><strong>Decision: Democratic policy management via governance proposals</strong></p>
<p><strong>Status:</strong> Complete (2025-11-24)</p>
<h4>11.3.1 Policy Architecture</h4>
<p><strong>Components:</strong></p>
<pre><code>PolicyManager
â”œâ”€â”€ CoopSchedulingPolicy    # Per-cooperative policy definition
â”œâ”€â”€ SchedulingRule[]        # Rule evaluation engine
â”œâ”€â”€ MemberQuota             # Resource limits per member
â”œâ”€â”€ UsageTracker            # Real-time usage monitoring
â””â”€â”€ EnforcementMode         # Strict vs Permissive
</code></pre>
<p><strong>Policy Schema:</strong></p>
<pre><code class="language-rust">pub struct CoopSchedulingPolicy {
    coop_id: String,
    governance_domain: Option&lt;String&gt;,
    rules: Vec&lt;SchedulingRule&gt;,
    member_quotas: HashMap&lt;String, MemberQuota&gt;,
    default_quota: MemberQuota,
    enforcement_mode: EnforcementMode,
}
</code></pre>
<hr>
<h4>11.3.2 Scheduling Rules</h4>
<p><strong>Decision: Composable rule system with 8 rule types</strong></p>
<p><strong>Available Rules:</strong></p>
<ol>
<li><strong>MemberPriority</strong>: Boost specific member&#39;s tasks (multiplier)</li>
<li><strong>RequireCapability</strong>: Executor must have capability (e.g., &quot;gpu-a100&quot;)</li>
<li><strong>DataSovereignty</strong>: Restrict tasks to geographic region</li>
<li><strong>TimeWindow</strong>: Allowed hours/days for specific priorities</li>
<li><strong>ExecutorFilter</strong>: Whitelist/blacklist executors</li>
<li><strong>QuotaOverride</strong>: Per-member quota customization</li>
<li><strong>TrustThreshold</strong>: Minimum trust score for executors</li>
<li><strong>Custom</strong>: Extensible rule type for future needs</li>
</ol>
<p><strong>Rule Evaluation:</strong></p>
<pre><code class="language-rust">// Sequential evaluation, fail-fast on any rejection
for rule in &amp;policy.rules {
    match rule {
        SchedulingRule::ExecutorFilter { whitelist, blacklist } =&gt; {
            if blacklist.contains(&amp;executor) { return Reject; }
            if !whitelist.is_empty() &amp;&amp; !whitelist.contains(&amp;executor) { return Reject; }
        }
        SchedulingRule::RequireCapability { capability, min_version } =&gt; {
            if !executor.has_capability(capability, min_version) { return Reject; }
        }
        // ... other rules
    }
}
</code></pre>
<hr>
<h4>11.3.3 Resource Quotas</h4>
<p><strong>Decision: Multi-resource quota system with per-member tracking</strong></p>
<p><strong>Quota Dimensions:</strong></p>
<pre><code class="language-rust">pub struct MemberQuota {
    cpu_hours_per_month: f64,       // Compute time limit
    max_concurrent_tasks: usize,    // Parallelism limit
    max_priority: TaskPriority,     // Highest priority allowed
    credits_per_month: Option&lt;u64&gt;, // Spending limit
}
</code></pre>
<p><strong>Usage Tracking:</strong></p>
<ul>
<li>Real-time monitoring via <code>UsageTracker</code></li>
<li>Monthly reset (configurable)</li>
<li>Quota checks at task submission</li>
<li>Automatic rejection when exceeded</li>
</ul>
<p><strong>Enforcement Modes:</strong></p>
<ul>
<li><strong>Strict</strong>: Hard rejection when quota exceeded</li>
<li><strong>Permissive</strong>: Warning only, metrics recorded</li>
</ul>
<hr>
<h4>11.3.4 Governance Integration</h4>
<p><strong>Decision: Democratic policy updates via Phase 13 governance</strong></p>
<p><strong>Proposal Flow:</strong></p>
<pre><code>1. Member creates SchedulingPolicy proposal
2. Cooperative members vote
3. Proposal accepted â†’ SystemEvent::ProposalAccepted
4. Supervisor event handler parses policy JSON
5. ComputeHandle.set_policy() updates PolicyManager
6. Audit trail stored: gov:audit:policy:{proposal_id}
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><code class="language-rust">// Supervisor event subscription (supervisor.rs:1415-1511)
event_bus.subscribe(Arc::new(move |event| {
    match event {
        SystemEvent::ProposalAccepted { payload: ProposalPayload::SchedulingPolicy { policy_json, .. }, .. } =&gt; {
            // 1. Idempotency check (audit trail)
            // 2. Parse policy JSON
            // 3. compute_handle.set_policy(policy)
            // 4. Store audit trail
            // 5. Emit metrics
        }
    }
}))
</code></pre>
<p><strong>Audit Trail:</strong></p>
<pre><code class="language-json">{
  &quot;proposal_id&quot;: &quot;prop-123&quot;,
  &quot;coop_id&quot;: &quot;research-lab&quot;,
  &quot;decided_at&quot;: 1700000000,
  &quot;executed_at&quot;: 1700000010
}
</code></pre>
<p><strong>Security:</strong></p>
<ul>
<li><strong>Idempotency</strong>: Audit trail prevents duplicate execution</li>
<li><strong>Authorization</strong>: Only proposals from governance domain accepted</li>
<li><strong>Validation</strong>: Policy JSON schema validation before application</li>
</ul>
<p><strong>Metrics:</strong></p>
<ul>
<li><code>proposals_executed_inc(&quot;scheduling_policy&quot;)</code></li>
<li><code>execution_duration_record(&quot;scheduling_policy&quot;, duration)</code></li>
<li><code>execution_failures_inc(&quot;policy_parse&quot; | &quot;policy_apply&quot;)</code></li>
</ul>
<hr>
<h3>11.4 Example Policies</h3>
<p><strong>1. Basic Cooperative:</strong></p>
<pre><code class="language-json">{
  &quot;coop_id&quot;: &quot;maker-space&quot;,
  &quot;rules&quot;: [],
  &quot;default_quota&quot;: {
    &quot;cpu_hours_per_month&quot;: 50.0,
    &quot;max_concurrent_tasks&quot;: 5,
    &quot;max_priority&quot;: &quot;Normal&quot;,
    &quot;credits_per_month&quot;: 500
  },
  &quot;enforcement_mode&quot;: &quot;Strict&quot;
}
</code></pre>
<p><strong>2. GDPR-Compliant Healthcare:</strong></p>
<pre><code class="language-json">{
  &quot;coop_id&quot;: &quot;health-coop&quot;,
  &quot;governance_domain&quot;: &quot;governance:health&quot;,
  &quot;rules&quot;: [
    {
      &quot;DataSovereignty&quot;: {
        &quot;allowed_regions&quot;: [&quot;eu-central&quot;, &quot;eu-west&quot;],
        &quot;prohibited_regions&quot;: [&quot;us-east&quot;, &quot;asia-pacific&quot;]
      }
    },
    {
      &quot;RequireCapability&quot;: {
        &quot;capability&quot;: &quot;hipaa-compliant&quot;,
        &quot;min_version&quot;: &quot;1.0&quot;
      }
    }
  ],
  &quot;default_quota&quot;: {
    &quot;cpu_hours_per_month&quot;: 20.0,
    &quot;max_concurrent_tasks&quot;: 3,
    &quot;max_priority&quot;: &quot;High&quot;,
    &quot;credits_per_month&quot;: 200
  },
  &quot;enforcement_mode&quot;: &quot;Strict&quot;
}
</code></pre>
<p><strong>3. Time-Restricted Research Lab:</strong></p>
<pre><code class="language-json">{
  &quot;coop_id&quot;: &quot;research-lab&quot;,
  &quot;rules&quot;: [
    {
      &quot;TimeWindow&quot;: {
        &quot;allowed_hours&quot;: [0, 1, 2, 3, 4, 5, 6, 20, 21, 22, 23],
        &quot;allowed_days&quot;: [0, 1, 2, 3, 4, 5, 6],
        &quot;priorities&quot;: [&quot;Low&quot;, &quot;Normal&quot;]
      }
    }
  ],
  &quot;default_quota&quot;: {
    &quot;cpu_hours_per_month&quot;: 100.0,
    &quot;max_concurrent_tasks&quot;: 10,
    &quot;max_priority&quot;: &quot;High&quot;,
    &quot;credits_per_month&quot;: 1000
  },
  &quot;enforcement_mode&quot;: &quot;Strict&quot;
}
</code></pre>
<hr>
<h3>11.5 API Surface</h3>
<p><strong>CLI Commands:</strong></p>
<pre><code class="language-bash"># Policy Management
icnctl policy set my-coop policy.json
icnctl policy get my-coop
icnctl policy list
icnctl policy delete my-coop

# Quota Management
icnctl quota show my-coop member-did
icnctl quota reset my-coop member-did
icnctl quota list my-coop
</code></pre>
<p><strong>RPC Methods:</strong></p>
<pre><code class="language-javascript">// policy.set
{&quot;coop_id&quot;: &quot;food-coop&quot;, &quot;policy&quot;: {&quot;rules&quot;: [], &quot;default_quota&quot;: {...}}}

// policy.get
{&quot;coop_id&quot;: &quot;food-coop&quot;}

// quota.get
{&quot;coop_id&quot;: &quot;food-coop&quot;, &quot;member_did&quot;: &quot;did:icn:abc123&quot;}

// quota.reset
{&quot;coop_id&quot;: &quot;food-coop&quot;, &quot;member_did&quot;: &quot;did:icn:abc123&quot;}
</code></pre>
<p><strong>Gateway REST API:</strong></p>
<pre><code>POST /v1/policy/:coop_id          # Set policy (requires coop:admin scope)
GET  /v1/policy/:coop_id          # Get policy
GET  /v1/quota/:coop_id/:did      # Get member quota
</code></pre>
<hr>
<h3>11.6 Future Enhancements</h3>
<p><strong>Planned:</strong></p>
<ul>
<li><strong>Phase 16F</strong>: Cost-aware scheduling (optimize for credits spent)</li>
<li><strong>Phase 16G</strong>: Multi-resource bidding (executors bid on tasks)</li>
<li><strong>Phase 16H</strong>: SLA enforcement (deadline guarantees, penalties)</li>
</ul>
<p><strong>Research:</strong></p>
<ul>
<li>Machine learning for workload prediction</li>
<li>Federated scheduling across cooperatives</li>
<li>Zero-knowledge task execution (privacy-preserving compute)</li>
</ul>
<hr>
<h3>11.7 Decision Rationale</h3>
<p><strong>Why democratic policy management?</strong></p>
<ul>
<li>Aligns with cooperative values (one-member-one-vote)</li>
<li>Prevents unilateral policy changes</li>
<li>Provides audit trail for compliance</li>
<li>Enables community-driven resource allocation</li>
</ul>
<p><strong>Why per-cooperative policies?</strong></p>
<ul>
<li>Different cooperatives have different needs (GDPR, cost sensitivity, priorities)</li>
<li>Enables experimentation (sandbox coops with permissive policies)</li>
<li>Clear governance boundaries (coop members control their rules)</li>
</ul>
<p><strong>Why composable rules?</strong></p>
<ul>
<li>Flexibility: Combine rules for complex policies</li>
<li>Extensibility: Add new rule types without breaking existing policies</li>
<li>Testability: Each rule type independently verifiable</li>
</ul>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li>âœ… Democratic, auditable, flexible</li>
<li>âœ… Supports diverse use cases (healthcare, research, industrial)</li>
<li>âœ… Governance integration prevents policy capture</li>
<li>âŒ Policy complexity (mitigated with example policies and documentation)</li>
<li>âŒ Per-cooperative overhead (acceptable, policies cached in memory)</li>
</ul>
<hr>
<h3>11.8 Integration Summary</h3>
<p><strong>How ICN components enable distributed compute:</strong></p>
<p>The compute layer is not a standalone systemâ€”it is the culmination of all ICN substrate components working together to provide a trust-aware, decentralized execution fabric:</p>
<ol>
<li><p><strong>Identity Layer (Section 1)</strong></p>
<ul>
<li>Every executor, submitter, and task is tied to a DID</li>
<li>Ed25519 signatures authenticate results and prevent forgery</li>
<li>Multi-device identity enables submitting tasks from mobile/web while executors run on servers</li>
</ul>
</li>
<li><p><strong>Trust Graph (Section 2)</strong></p>
<ul>
<li>Trust scores gate task submission (MIN_TRUST_SUBMIT = 0.1) and execution (MIN_TRUST_EXECUTE = 0.3)</li>
<li>Scheduler prioritizes executors with high trust (30% of placement score)</li>
<li>Prevents Sybil attacks: new nodes cannot execute tasks without trust relationships</li>
</ul>
</li>
<li><p><strong>Network Transport (Section 3)</strong></p>
<ul>
<li>QUIC/TLS provides encrypted, multiplexed task communication</li>
<li>mDNS enables LAN-local executor discovery (fast, low-latency placement)</li>
<li>Network topology awareness (Phase 16C) optimizes placement for same-cluster executors</li>
</ul>
</li>
<li><p><strong>Ledger (Section 4)</strong></p>
<ul>
<li>Automatic payment settlement: <code>(fuel_used Ã— payment_rate) / 1000</code> credits</li>
<li>Mutual credit enables cooperatives to compensate executors without fiat currency</li>
<li>Double-entry accounting ensures executors are paid for completed work</li>
</ul>
</li>
<li><p><strong>Contract Execution (Section 5)</strong></p>
<ul>
<li>CCL interpreter executes task code deterministically</li>
<li>Fuel metering prevents runaway execution</li>
<li>Capability isolation: tasks cannot access ledger/state without explicit grants</li>
</ul>
</li>
<li><p><strong>Gossip Protocol (Section 6)</strong></p>
<ul>
<li>Decentralized task distribution via <code>compute:submit</code>, <code>compute:claim</code>, <code>compute:result</code>, <code>compute:cancel</code> topics</li>
<li>Vector clocks ensure causal ordering of task state transitions</li>
<li>Anti-entropy guarantees eventual delivery even under network partitions</li>
</ul>
</li>
<li><p><strong>Data Storage (Section 7)</strong></p>
<ul>
<li>Persistent task queues survive node restarts</li>
<li>Sled-based storage for executor registries and task metadata</li>
<li>Graceful restart (Track B1) preserves task state across daemon updates</li>
</ul>
</li>
<li><p><strong>Security Model (Section 8)</strong></p>
<ul>
<li>Ed25519-signed results prevent result forgery</li>
<li>Trust-gated access prevents untrusted nodes from claiming tasks</li>
<li>Rate limiting prevents compute spam attacks</li>
</ul>
</li>
</ol>
<p><strong>This integration is what makes ICN&#39;s compute model unique:</strong></p>
<p>Unlike centralized schedulers (Kubernetes) or blockchain VMs (Ethereum), ICN compute is:</p>
<ul>
<li><strong>Trust-native:</strong> Placement decisions based on social relationships, not just resources</li>
<li><strong>Democratic:</strong> Policies governed by cooperative votes, not operators</li>
<li><strong>Local-first:</strong> Tasks distributed via gossip, not central coordinators</li>
<li><strong>Privacy-preserving:</strong> Executor capabilities advertised without revealing internal infrastructure</li>
<li><strong>Payment-integrated:</strong> Ledger settlement is automatic, not bolted-on</li>
</ul>
<p><strong>Example: Healthcare Cooperative Compute Workflow</strong></p>
<ol>
<li><strong>Doctor submits diagnostic task</strong> (DID verification, trust check: 0.5 &gt; 0.1 âœ“)</li>
<li><strong>Scheduler finds compliant executors</strong> (GDPR-region filter, HIPAA capability requirement)</li>
<li><strong>Executor claims task</strong> (trust score 0.7, capacity available, data local)</li>
<li><strong>CCL executes diagnosis</strong> (fuel-metered, no network access)</li>
<li><strong>Result returned</strong> (Ed25519-signed by executor)</li>
<li><strong>Payment settled</strong> (10,000 fuel Ã— 100 rate / 1000 = 1,000 credits)</li>
<li><strong>Governance</strong> (cooperative votes to adjust GDPR region policy via proposal)</li>
</ol>
<p>All eight substrate layers contribute to making this workflow secure, decentralized, and compliant.</p>
<hr>
<hr>
<h2>12. Known Limitations &amp; Future Work</h2>
<p>This section documents acknowledged gaps, limitations, and planned improvements for ICN. It serves as both a roadmap for future development and transparent disclosure of current system boundaries.</p>
<p><strong>Summary Status (as of 2025-12):</strong></p>
<ul>
<li>âœ… <strong>12.1</strong> Byzantine Fault Tolerance - Implemented</li>
<li>âœ… <strong>12.2</strong> Network Partition Healing - Implemented</li>
<li>â³ <strong>12.3</strong> Contract Execution Disputes - Partial</li>
<li>âœ… <strong>12.4</strong> Ledger Fork Resolution - Implemented</li>
<li>âœ… <strong>12.5</strong> Storage Exhaustion Protection - Implemented</li>
<li>â³ <strong>12.6</strong> Upgrade Coordination - Not started</li>
<li>â³ <strong>12.7</strong> Scalability Limits - Documented, testing ongoing</li>
<li>âœ… <strong>12.8</strong> Clock Synchronization - Implemented</li>
<li>âœ… <strong>12.9</strong> Privacy &amp; Metadata Leakage - Implemented</li>
<li>â³ <strong>12.10</strong> Trust Graph Gaming - Not started</li>
</ul>
<h3>12.1 Byzantine Fault Tolerance</h3>
<p><strong>Status:</strong> âœ… <strong>IMPLEMENTED</strong> (Phase 18 Week 1-2)</p>
<p><strong>Current State:</strong> ICN implements comprehensive Byzantine fault detection and mitigation via the <code>icn-security</code> crate.</p>
<p><strong>What Works:</strong></p>
<ul>
<li>âœ… Sybil resistance via trust graph</li>
<li>âœ… Message authentication (Ed25519 signatures)</li>
<li>âœ… Replay protection (sequence numbers + Bloom filters)</li>
<li>âœ… Trust-gated access control</li>
<li>âœ… Automatic detection of conflicting signed statements</li>
<li>âœ… Reputation scoring with automatic trust penalties</li>
<li>âœ… Quarantine mechanism for malicious nodes</li>
<li>âœ… Integration with trust graph for penalty callbacks</li>
</ul>
<p><strong>Implementation:</strong></p>
<p>Located in <code>icn-security/src/misbehavior.rs</code>:</p>
<pre><code class="language-rust">pub struct MisbehaviorDetector {
    violations: HashMap&lt;Did, Vec&lt;ViolationRecord&gt;&gt;,
    thresholds: MisbehaviorThresholds,
    reputation_scores: HashMap&lt;Did, ReputationScore&gt;,
    trust_penalty_callback: Option&lt;TrustPenaltyCallback&gt;,
}

pub enum Violation {
    InvalidSignature { message_hash: ContentHash },
    ConflictingLedgerEntries { entry1: ContentHash, entry2: ContentHash },
    FailedComputeVerification { task_hash: ContentHash, expected: ContentHash, actual: ContentHash },
    ExcessiveResourceUse { metric: String, observed: u64, limit: u64 },
    TrustGraphSpam { rate_per_hour: f64, threshold: f64 },
    ConflictingSignedStatements { statement1: ContentHash, statement2: ContentHash, conflict_type: String },
    ReplayAttack { message_hash: ContentHash, sequence: u64 },
}
</code></pre>
<p><strong>Severity Scoring:</strong></p>
<ul>
<li>Critical (10 points): ConflictingLedgerEntries, ConflictingSignedStatements, ReplayAttack</li>
<li>Major (5 points): FailedComputeVerification, InvalidSignature</li>
<li>Minor (1 point): ExcessiveResourceUse, TrustGraphSpam</li>
</ul>
<p><strong>Integration Points:</strong></p>
<ul>
<li>Shared <code>MisbehaviorDetector</code> between NetworkActor and GossipActor (<code>icn-core/src/supervisor.rs</code>)</li>
<li>Trust penalty callback automatically updates trust graph</li>
<li>Ledger detects conflicting entries and reports violations (<code>icn-ledger/src/ledger.rs</code>)</li>
</ul>
<p><strong>Integration Test:</strong> <code>icn-core/tests/byzantine_integration.rs</code></p>
<p><strong>Metrics:</strong></p>
<ul>
<li><code>icn_misbehavior_violations_detected_total{violation_type}</code></li>
<li><code>icn_misbehavior_reputation_updated_total</code></li>
<li><code>icn_misbehavior_quarantined_total</code></li>
</ul>
<p><strong>Remaining Work:</strong></p>
<ul>
<li>âŒ Detection of selective message dropping (requires protocol-level heartbeats)</li>
<li>âŒ Community reporting mechanism via governance</li>
</ul>
<hr>
<h3>12.2 Network Partition Healing</h3>
<p><strong>Status:</strong> âœ… <strong>IMPLEMENTED</strong> (Phase 18 Week 3)</p>
<p><strong>Current State:</strong> ICN implements comprehensive partition detection and healing via the <code>icn-gossip</code> crate.</p>
<p><strong>What Works:</strong></p>
<ul>
<li>âœ… Causal consistency with vector clocks</li>
<li>âœ… Anti-entropy Bloom filter exchange</li>
<li>âœ… Deterministic merge ordering</li>
<li>âœ… Partition detection with configurable threshold (default: 5 min)</li>
<li>âœ… Divergence detection with version gaps</li>
<li>âœ… Policy-based conflict resolution per data type</li>
<li>âœ… Automatic healing for gossip/trust; manual for ledger</li>
</ul>
<p><strong>Implementation:</strong></p>
<p>Located in <code>icn-gossip/src/partition.rs</code>:</p>
<pre><code class="language-rust">pub struct PartitionDetector {
    last_seen: HashMap&lt;Did, Instant&gt;,
    config: PartitionConfig,  // Default: 5min threshold, 30s check interval
}

pub struct PartitionHealer {
    merger: VectorClockMerger,
    resolver: ConflictResolver,
    healing_in_progress: HashMap&lt;Did, Instant&gt;,
}

pub enum ConflictResolution {
    KeepLocal,
    KeepRemote,
    KeepBoth,        // For append-only data (gossip)
    LastWriteWins,   // For trust edges, contracts
    RequiresManual,  // For ledger entries
}
</code></pre>
<p><strong>Default Resolution Policies:</strong></p>
<ul>
<li>LedgerEntry: <code>RequiresManual</code> (critical financial data)</li>
<li>Contract: <code>LastWriteWins</code> (timestamp-based)</li>
<li>TrustEdge: <code>LastWriteWins</code> (timestamp-based)</li>
<li>GossipEntry: <code>KeepBoth</code> (append-only)</li>
</ul>
<p><strong>Version Gap Detection (H8 Enhancement):</strong></p>
<pre><code class="language-rust">pub struct VersionGap {
    author_did: Did,
    local_version: u64,
    remote_version: u64,
    direction: GapDirection,  // RemoteAhead, LocalAhead, Diverged
}
</code></pre>
<p><strong>Integration Points:</strong></p>
<ul>
<li>Partition detector set on GossipActor (<code>icn-core/src/supervisor.rs</code>)</li>
<li>PartitionHealer invoked during vector clock merge</li>
<li>Metrics tracked for partition events</li>
</ul>
<p><strong>Integration Test:</strong> <code>icn-core/tests/partition_integration.rs</code></p>
<p><strong>Remaining Work:</strong></p>
<ul>
<li>âŒ Split-brain detection for governance domains</li>
<li>âŒ Operator alerts for long-duration partitions (&gt;24h)</li>
</ul>
<hr>
<h3>12.3 Contract Execution Disputes</h3>
<p><strong>Current State:</strong> CCL interpreter is deterministic but lacks multi-executor verification and dispute resolution.</p>
<p><strong>What Works:</strong></p>
<ul>
<li>âœ… Deterministic execution (same inputs â†’ same outputs)</li>
<li>âœ… Fuel metering prevents runaway execution</li>
<li>âœ… Ed25519-signed results</li>
</ul>
<p><strong>What&#39;s Missing:</strong></p>
<ul>
<li>âŒ No automatic detection of differing execution results</li>
<li>âŒ No multi-executor verification (consensus on results)</li>
<li>âŒ No slashing for incorrect execution</li>
</ul>
<p><strong>Planned (Phase 18):</strong></p>
<pre><code class="language-rust">pub struct ComputeDispute {
    task_hash: ContentHash,
    submitter: Did,
    executors: Vec&lt;(Did, ComputeResult)&gt;,
    evidence: Vec&lt;Evidence&gt;,
    initiated_at: u64,
    resolution: Option&lt;DisputeResolution&gt;,
}

pub enum DisputeResolution {
    Consensus { result: ComputeResult, majority: usize, minority: usize },
    Reexecution { arbiter: Did, result: ComputeResult },
    Quarantine { reason: String },
}
</code></pre>
<p><strong>Multi-Executor Verification (Optional):</strong></p>
<ul>
<li>Submitter can request N executors (N=3, 5, etc.)</li>
<li>Results compared via content hash</li>
<li>Majority consensus determines payment</li>
<li>Minority executors penalized (reputation hit)</li>
</ul>
<p><strong>Dispute Workflow:</strong></p>
<pre><code>1. Differing results detected
   â†’ Create ComputeDispute record

2. Evidence collection (24h window)
   â†’ Executors submit execution logs
   â†’ Submitter provides input data

3. Re-execution by arbiter
   â†’ High-trust node re-runs task
   â†’ Arbiter result is canonical

4. Resolution
   â†’ Correct executors paid
   â†’ Incorrect executors penalized
   â†’ Audit trail stored
</code></pre>
<hr>
<h3>12.4 Ledger Fork Resolution</h3>
<p><strong>Status:</strong> âœ… <strong>IMPLEMENTED</strong> (Phase 18 Week 5)</p>
<p><strong>Current State:</strong> ICN implements comprehensive fork detection and resolution via <code>icn-ledger/src/fork_resolution.rs</code>.</p>
<p><strong>What Works:</strong></p>
<ul>
<li>âœ… Deterministic ordering (timestamp, author DID, entry hash)</li>
<li>âœ… Quarantine for invalid entries</li>
<li>âœ… Invariant checking (double-entry, credit limits)</li>
<li>âœ… Fork detection (same parents, different hashes)</li>
<li>âœ… Multiple resolution strategies (timestamp, trust, signatures, hybrid)</li>
<li>âœ… Trust-weighted resolution with TrustGraph integration</li>
</ul>
<p><strong>Implementation:</strong></p>
<p>Located in <code>icn-ledger/src/fork_resolution.rs</code>:</p>
<pre><code class="language-rust">pub enum ForkResolutionStrategy {
    TimestampPreference,    // First-write-wins (simple coordination)
    TrustWeighted,          // Prefer higher-trust participant
    MajoritySignatures,     // Prefer entry with more co-signatures
    Hybrid,                 // Combination (default for production)
}

pub struct ForkResolver {
    strategy: ForkResolutionStrategy,
    trust_graph: Option&lt;Arc&lt;TrustGraph&gt;&gt;,
}

pub struct Fork {
    common_parents: Vec&lt;ContentHash&gt;,
    entry1: JournalEntry,
    entry2: JournalEntry,
    detected_at: SystemTime,
}

pub enum ForkResolution {
    KeepFirst,
    KeepSecond,
    RequiresManual { reason: String },
}
</code></pre>
<p><strong>Resolution Strategies:</strong></p>
<ul>
<li><strong>TimestampPreference</strong>: First-write-wins, author DID as tiebreaker</li>
<li><strong>TrustWeighted</strong>: Prefer entry from higher-trust participant</li>
<li><strong>MajoritySignatures</strong>: Prefer entry with more co-signatures</li>
<li><strong>Hybrid</strong> (default): Trust score (50%) + timestamp (30%) + signatures (20%)</li>
</ul>
<p><strong>Hybrid Scoring:</strong></p>
<pre><code class="language-rust">fn resolve_hybrid(...) -&gt; Result&lt;ForkResolution&gt; {
    let mut score1: f64 = 0.0;
    let mut score2: f64 = 0.0;

    // Trust component (50%): higher trust = higher score
    // Timestamp component (30%): earlier timestamp = higher score
    // Signature component (20%): more co-signers = higher score
}
</code></pre>
<p><strong>Remaining Work:</strong></p>
<ul>
<li>âŒ Multi-party mediation workflow for <code>RequiresManual</code> cases</li>
<li>âŒ Governance integration for severe forks (overdrafts/double-spends)</li>
</ul>
<hr>
<h3>12.5 Storage Exhaustion Protection</h3>
<p><strong>Status:</strong> âœ… <strong>IMPLEMENTED</strong> (Phase 18 Week 6)</p>
<p><strong>Current State:</strong> ICN implements storage quota management with priority-based eviction via <code>icn-store/src/quotas.rs</code>.</p>
<p><strong>What Works:</strong></p>
<ul>
<li>âœ… Per-DID storage quotas</li>
<li>âœ… Global storage limit enforcement</li>
<li>âœ… Priority-based eviction (Low â†’ Normal â†’ High â†’ Critical)</li>
<li>âœ… Eviction threshold triggering (default: 90% capacity)</li>
<li>âœ… Integration with GossipActor for entry limits</li>
</ul>
<p><strong>Implementation:</strong></p>
<p>Located in <code>icn-store/src/quotas.rs</code>:</p>
<pre><code class="language-rust">pub enum QuotaPriority {
    Low = 0,      // Evicted first (cached data, temp files)
    Normal = 1,   // Evicted second (gossip entries, routine data)
    High = 2,     // Evicted third (contracts, trust edges)
    Critical = 3, // Never auto-evicted (keystore, ledger, governance)
}

pub struct StorageQuotaManager {
    quotas: HashMap&lt;Did, StorageQuota&gt;,
    global_limit: u64,            // Total limit across all DIDs
    global_usage: u64,
    items: Vec&lt;StorageItem&gt;,      // Tracked for eviction
    eviction_threshold: f64,      // Default: 0.9 (90%)
}

pub struct StorageQuota {
    max_bytes: u64,
    current_bytes: u64,
    priority: QuotaPriority,
    updated_at: SystemTime,
}
</code></pre>
<p><strong>Integration Points:</strong></p>
<ul>
<li>Supervisor creates <code>StorageQuotaManager</code> (1GB global, 90% eviction threshold)</li>
<li>GossipActor uses quota manager to check entry limits (<code>icn-core/src/supervisor.rs</code>)</li>
<li>Per-DID quotas default to 10MB</li>
</ul>
<p><strong>Eviction Strategy:</strong></p>
<ol>
<li>Sort items by priority (lowest first), then age (oldest first)</li>
<li>Evict items until below threshold</li>
<li>Skip <code>Critical</code> priority items</li>
</ol>
<p><strong>Remaining Work:</strong></p>
<ul>
<li>âŒ Disk-level monitoring (filesystem usage vs in-memory tracking)</li>
<li>âŒ Operator alerts for emergency pruning</li>
<li>âŒ Configurable pruning schedules</li>
</ul>
<p><strong>Metrics:</strong></p>
<ul>
<li><code>icn_storage_disk_usage_bytes</code></li>
<li><code>icn_storage_pruning_events_total</code></li>
<li><code>icn_storage_emergency_pruning_total</code></li>
</ul>
<hr>
<h3>12.6 Upgrade Coordination</h3>
<p><strong>Current State:</strong> Section 10.5 describes manual upgrade process but lacks in-protocol coordination.</p>
<p><strong>What&#39;s Missing:</strong></p>
<ul>
<li>âŒ No governance-driven protocol upgrades</li>
<li>âŒ No automatic version negotiation for major bumps</li>
<li>âŒ No network-wide upgrade deadlines</li>
</ul>
<p><strong>Planned (Phase 18):</strong></p>
<pre><code class="language-rust">pub struct UpgradeProposal {
    new_version: Version,
    breaking_changes: Vec&lt;String&gt;,
    migration_code: Option&lt;MigrationCode&gt;,
    deadline: u64,  // Unix timestamp
    required_approval: f64,  // e.g., 0.66 for 2/3 majority
}

// Governance integration
ProposalPayload::ProtocolUpgrade {
    version: Version,
    migration: MigrationCode,
    deadline: u64,
}
</code></pre>
<p><strong>Upgrade Workflow:</strong></p>
<pre><code>1. Proposal Creation
   â†’ Core team proposes upgrade
   â†’ Includes migration guide
   â†’ Sets reasonable deadline (e.g., 90 days)

2. Community Review
   â†’ Governance vote
   â†’ 2/3 majority required for breaking changes
   â†’ 1/2 majority for non-breaking

3. Adoption Period
   â†’ Nodes upgrade at their pace
   â†’ Version negotiation handles mixed network
   â†’ Metrics track adoption rate

4. Deadline Enforcement
   â†’ Old nodes warned (30 days before)
   â†’ Old nodes deprecated (at deadline)
   â†’ Network refuses connections from ancient versions
</code></pre>
<p><strong>Metrics:</strong></p>
<ul>
<li><code>icn_upgrade_proposals_total</code></li>
<li><code>icn_upgrade_adoption_rate{version}</code></li>
<li><code>icn_upgrade_deadline_warnings_sent</code></li>
</ul>
<hr>
<h3>12.7 Scalability Limits</h3>
<p><strong>Current State:</strong> Section 9.1 has target metrics but no documented breaking points.</p>
<p><strong>Tested Bounds (v1):</strong></p>
<table>
<thead>
<tr>
<th>Dimension</th>
<th>Tested</th>
<th>Target</th>
<th>Breaking Point</th>
</tr>
</thead>
<tbody><tr>
<td>Nodes per cooperative</td>
<td>10</td>
<td>100</td>
<td>~1,000 (vector clock overhead)</td>
</tr>
<tr>
<td>Transactions per second</td>
<td>10/node</td>
<td>100/node</td>
<td>~500/node (signature verification CPU)</td>
</tr>
<tr>
<td>Trust graph size</td>
<td>100 DIDs</td>
<td>1,000 DIDs</td>
<td>~10,000 (computation time)</td>
</tr>
<tr>
<td>Gossip topics</td>
<td>10</td>
<td>100</td>
<td>~1,000 (memory overhead)</td>
</tr>
<tr>
<td>Storage per node</td>
<td>1 GB</td>
<td>100 GB</td>
<td>~1 TB (Sled limit)</td>
</tr>
<tr>
<td>mDNS discovery</td>
<td>5 LAN nodes</td>
<td>50 LAN nodes</td>
<td>~100 (broadcast storm)</td>
</tr>
</tbody></table>
<p><strong>Known Bottlenecks:</strong></p>
<ol>
<li><p><strong>Vector Clock Growth:</strong> O(n) per message where n = number of peers</p>
<ul>
<li>Mitigation: Sparse vector clocks (only active participants)</li>
</ul>
</li>
<li><p><strong>Trust Graph Computation:</strong> O(nÂ²) for transitive trust</p>
<ul>
<li>Mitigation: Cache scores, recompute only on edge changes</li>
</ul>
</li>
<li><p><strong>Bloom Filter Size:</strong> O(m) where m = entries per topic</p>
<ul>
<li>Mitigation: Configurable false-positive rate, periodic compaction</li>
</ul>
</li>
<li><p><strong>Signature Verification:</strong> CPU-bound, ~1ms per signature</p>
<ul>
<li>Mitigation: Batch verification, async verification queue</li>
</ul>
</li>
</ol>
<p><strong>Mitigation Strategies:</strong></p>
<ul>
<li>Cooperative-based sharding (different coops = different gossip neighborhoods)</li>
<li>Specialized archival nodes (high storage, low compute)</li>
<li>Regional topology clustering (reduce cross-region gossip)</li>
</ul>
<hr>
<h3>12.8 Clock Synchronization</h3>
<p><strong>Status:</strong> âœ… <strong>IMPLEMENTED</strong> (Phase 19 Week 3-4)</p>
<p><strong>Current State:</strong> ICN implements clock synchronization via the <code>icn-time</code> crate using Rough Time Protocol (RFC 8915).</p>
<p><strong>What Works:</strong></p>
<ul>
<li>âœ… Rough Time protocol implementation</li>
<li>âœ… Clock offset calculation from network median</li>
<li>âœ… Timestamp validation with Â±300s tolerance</li>
<li>âœ… Integration with supervisor for distributed time consensus</li>
<li>âœ… Configurable trusted time servers</li>
</ul>
<p><strong>Implementation:</strong></p>
<p>Located in <code>icn-time/src/sync.rs</code>:</p>
<pre><code class="language-rust">pub struct ClockSync {
    /// Local clock offset from network median (milliseconds)
    pub offset_millis: i64,

    /// Confidence interval / uncertainty
    pub uncertainty: Duration,

    /// Last successful sync time
    pub last_sync: Option&lt;Instant&gt;,

    /// Maximum acceptable clock skew (default: 300s)
    pub max_clock_skew: Duration,

    /// Configured Rough Time servers
    trusted_servers: Vec&lt;RoughTimeServer&gt;,
}

// Default servers
pub fn default_servers() -&gt; Vec&lt;RoughTimeServer&gt; {
    vec![
        &quot;roughtime.cloudflare.com:2003&quot;,
        &quot;roughtime.int08h.com:2002&quot;,
        &quot;roughtime.sandbox.google.com:2002&quot;,
    ]
}
</code></pre>
<p><strong>Key Parameters:</strong></p>
<ul>
<li><code>MAX_CLOCK_SKEW</code>: 300 seconds (5 minutes)</li>
<li><code>MIN_SERVERS</code>: 3 (for median calculation)</li>
<li><code>QUERY_TIMEOUT</code>: 5 seconds</li>
</ul>
<p><strong>Integration Test:</strong> <code>icn-time/tests/time_integration.rs</code></p>
<p><strong>Remaining Work:</strong></p>
<ul>
<li>âŒ Operator alerts for severe clock skew (&gt;60s drift)</li>
<li>âŒ Automatic periodic re-sync in background task</li>
</ul>
<p><strong>Metrics:</strong></p>
<ul>
<li><code>icn_time_clock_drift_seconds</code></li>
<li><code>icn_time_ntp_sync_failures_total</code></li>
<li><code>icn_time_skew_rejections_total</code></li>
</ul>
<hr>
<h3>12.9 Privacy &amp; Metadata Leakage</h3>
<p><strong>Current State:</strong> TLS encryption protects content, and privacy layer provides optional metadata protection.</p>
<p><strong>Observable by Network Observer (without privacy enabled):</strong></p>
<ul>
<li>Connection graph (who connects to whom)</li>
<li>Gossip topic subscriptions (interest patterns)</li>
<li>Message timing and sizes (traffic analysis)</li>
<li>Compute task submission patterns</li>
</ul>
<p><strong>Privacy Layer (Phase 20 - Integrated 2025-11-28):</strong></p>
<p>The <code>icn-privacy</code> crate provides metadata protection, integrated into <code>icn-net</code>:</p>
<ol>
<li><p><strong>Onion Routing</strong> (Implemented âœ…):</p>
<ul>
<li>Multi-hop message routing (Tor-like architecture)</li>
<li>X25519/ChaCha20-Poly1305 layer encryption</li>
<li>Trust-based relay selection (<code>select_onion_relays()</code>)</li>
<li>Configurable hop count (2-5 recommended)</li>
<li><code>NetworkHandle::send_onion_message()</code> for privacy sends</li>
</ul>
</li>
<li><p><strong>Topic Encryption</strong> (Implemented âœ…):</p>
<ul>
<li>ChaCha20-Poly1305 AEAD topic name encryption</li>
<li>Bloom filter-based topic discovery (plausible deniability)</li>
<li><code>TopicEncryptor</code> and <code>TopicBloomFilter</code> types</li>
</ul>
</li>
<li><p><strong>Traffic Obfuscation</strong> (Implemented âœ…):</p>
<ul>
<li>Message padding to hide content sizes</li>
<li>Random delays for timing attack resistance</li>
<li>Cover traffic generation (decoy messages)</li>
<li><code>TrafficObfuscator</code> with configurable parameters</li>
</ul>
</li>
</ol>
<p><strong>Configuration</strong> (<code>privacy</code> section in config):</p>
<pre><code class="language-toml">[privacy]
enabled = true
onion_routing_enabled = true
onion_hops = 2
min_relay_trust = 0.3
topic_encryption_enabled = true
traffic_obfuscation_enabled = true
padding_target = 1024
max_delay_ms = 100
cover_traffic_rate = 5
</code></pre>
<p><strong>Prometheus Metrics:</strong></p>
<ul>
<li><code>icn_privacy_onion_routes_created_total</code></li>
<li><code>icn_privacy_onion_hops_forwarded_total</code></li>
<li><code>icn_privacy_onion_messages_received_total</code></li>
<li><code>icn_privacy_onion_messages_delivered_total</code></li>
<li><code>icn_privacy_onion_routing_errors_total</code></li>
<li><code>icn_privacy_topics_encrypted_total</code></li>
<li><code>icn_privacy_cover_traffic_sent_total</code></li>
</ul>
<hr>
<h3>12.10 Trust Graph Gaming</h3>
<p><strong>Current State:</strong> Transitive trust prevents some gaming but lacks anomaly detection.</p>
<p><strong>Potential Attack Vectors:</strong></p>
<ul>
<li>Circular vouching (A trusts B trusts C trusts A)</li>
<li>Trust inflation via Sybil identities</li>
<li>Fake evidence generation</li>
</ul>
<p><strong>Planned (Phase 19):</strong></p>
<pre><code class="language-rust">pub struct TrustGraphAnalyzer {
    anomaly_detector: AnomalyDetector,
    circular_vouch_detector: CircularVouchDetector,
    sybil_detector: SybilDetector,
}

pub enum TrustAnomaly {
    CircularVouching { cycle: Vec&lt;Did&gt; },
    TrustInflation { did: Did, suspicious_edges: Vec&lt;TrustEdge&gt; },
    SybilCluster { cluster: Vec&lt;Did&gt;, evidence: String },
}
</code></pre>
<p><strong>Detection Strategies:</strong></p>
<ul>
<li>Graph cycle detection (find circular trust chains)</li>
<li>Trust score velocity monitoring (rapid changes suspicious)</li>
<li>Evidence quality analysis (weak evidence = low weight)</li>
<li>Community reporting + manual review</li>
</ul>
<p><strong>Metrics:</strong></p>
<ul>
<li><code>icn_trust_anomalies_detected_total{type}</code></li>
<li><code>icn_trust_circular_vouching_incidents</code></li>
<li><code>icn_trust_inflation_warnings</code></li>
</ul>
<hr>
<h3>12.11 Implementation Priorities</h3>
<p><strong>Phase 17 (Storage Hardening) - Complete âœ…:</strong></p>
<ul>
<li>âœ… Section 7.4 (Data Replication)</li>
<li>âœ… Trust-weighted automatic replication</li>
<li>âœ… Replica tracking and monitoring</li>
<li>âœ… Re-replication on node failure</li>
</ul>
<p><strong>Phase 18 (Pre-Pilot Hardening) - Complete âœ…:</strong></p>
<ol>
<li>âœ… Byzantine fault detection (12.1) - <code>icn-security/src/misbehavior.rs</code></li>
<li>âœ… Network partition healing (12.2) - <code>icn-gossip/src/partition.rs</code></li>
<li>â³ Contract execution disputes (12.3) - Partially complete</li>
<li>âœ… Ledger fork resolution (12.4) - <code>icn-ledger/src/fork_resolution.rs</code></li>
<li>âœ… Storage exhaustion protection (12.5) - <code>icn-store/src/quotas.rs</code></li>
<li>â³ Upgrade coordination via governance (12.6) - Not yet started</li>
</ol>
<p><strong>Phase 19 (Post-Pilot Improvements) - In Progress:</strong>
7. âœ… Clock synchronization (12.8) - <code>icn-time/src/sync.rs</code>
8. â³ Scalability testing &amp; documentation (12.7) - Ongoing
9. âŒ Trust graph gaming detection (12.10) - Not yet started</p>
<p><strong>Phase 20 (Complete âœ…):</strong>
10. âœ… Privacy &amp; metadata protection (12.9) - Onion routing, topic encryption, traffic obfuscation integrated</p>
<p><strong>Remaining Work:</strong></p>
<ul>
<li>Contract execution disputes: Multi-executor verification, slashing</li>
<li>Upgrade coordination: Governance-driven protocol upgrades</li>
<li>Trust graph gaming: Anomaly detection for circular vouching, Sybil clusters</li>
</ul>
<p><strong>Production-Ready Status:</strong> Core infrastructure complete. Pilot deployment active.</p>
<hr>
<h2>13. Node Morphogenesis</h2>
<p>This section describes how ICN nodes adapt to their environmentâ€”acquiring capabilities and roles based on available hardware, operator policy, and network needs. Like biological stem cells that differentiate based on environmental signals, ICN nodes start undifferentiated and grow into their roles.</p>
<h3>13.1 Design Philosophy</h3>
<p><strong>Core Insight:</strong> Nodes are not fixed categories. A device&#39;s role emerges from:</p>
<ol>
<li><strong>Hardware capabilities</strong> - What can it physically do?</li>
<li><strong>Operator policy</strong> - What does the operator permit?</li>
<li><strong>Network needs</strong> - What does the cooperative require?</li>
</ol>
<p><strong>Metaphor: Stem Cells</strong></p>
<p>Biological stem cells start undifferentiated and specialize based on environmental signals. ICN nodes follow the same pattern:</p>
<pre><code>[Fresh Install] â†’ [Sense Environment] â†’ [Acquire Roles] â†’ [Active Participation]
                        â†“                      â†“
                  Hardware probe         Policy check
                  Resource detect        Trust evaluation
                  Network discovery      Capability match
</code></pre>
<p><strong>Anti-patterns avoided:</strong></p>
<ul>
<li>âŒ Hard-coded node types (&quot;this is a mobile node&quot;)</li>
<li>âŒ Static role assignment at install time</li>
<li>âŒ One-size-fits-all resource requirements</li>
<li>âŒ Admin-configured categories</li>
</ul>
<p><strong>Patterns embraced:</strong></p>
<ul>
<li>âœ… Capabilities emerge from environment sensing</li>
<li>âœ… Roles are additive (a node gains roles, not assigned a category)</li>
<li>âœ… Policy constrains but doesn&#39;t dictate</li>
<li>âœ… Dynamic adaptation as conditions change</li>
</ul>
<hr>
<h3>13.2 Principal vs Node Identity</h3>
<p><strong>Critical distinction:</strong> ICN separates <em>who you are</em> from <em>what device you&#39;re using</em>.</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Identity Layer</th>
<th>Network Layer</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Principal DID</strong></td>
<td>User or organization identity</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>Node DID</strong></td>
<td>N/A</td>
<td>Device identity for network operations</td>
</tr>
<tr>
<td><strong>Purpose</strong></td>
<td>Authentication, ownership, governance</td>
<td>Routing, task execution, storage</td>
</tr>
<tr>
<td><strong>Lifecycle</strong></td>
<td>Long-lived (years)</td>
<td>Device-bound (hardware lifecycle)</td>
</tr>
<tr>
<td><strong>Multi-device</strong></td>
<td>One principal â†’ many node DIDs</td>
<td>Each node has exactly one DID</td>
</tr>
</tbody></table>
<p><strong>Example:</strong></p>
<pre><code>Principal: did:icn:alice (Alice&#39;s identity)
    â”œâ”€â”€ Node: did:icn:alice-laptop (MacBook, high capacity)
    â”œâ”€â”€ Node: did:icn:alice-phone (iPhone, limited capacity)
    â””â”€â”€ Node: did:icn:alice-server (VPS, always-on)
</code></pre>
<p><strong>Why separate?</strong></p>
<ul>
<li><strong>Key compromise isolation</strong> - Losing a phone doesn&#39;t compromise the principal</li>
<li><strong>Capability scoping</strong> - Phone might only relay, not execute contracts</li>
<li><strong>Trust independence</strong> - Principal trust score â‰  node trust score</li>
<li><strong>Shared devices</strong> - Multiple principals can use one node (kiosk, lab computer)</li>
</ul>
<p><strong>Shared device example:</strong></p>
<pre><code>Node: did:icn:coop-kiosk (shared terminal)
    â”œâ”€â”€ Operator: did:icn:food-coop (owns/maintains)
    â”œâ”€â”€ User: did:icn:alice (authenticates, uses services)
    â”œâ”€â”€ User: did:icn:bob (authenticates, uses services)
    â””â”€â”€ User: did:icn:charlie (authenticates, uses services)
</code></pre>
<hr>
<h3>13.3 ServiceRole &amp; Capabilities</h3>
<p><strong>ServiceRole</strong> unifies three existing concepts:</p>
<table>
<thead>
<tr>
<th>Source</th>
<th>Concept</th>
<th>Unified As</th>
</tr>
</thead>
<tbody><tr>
<td><code>icn-net/topology.rs</code></td>
<td><code>NodeRole</code> (Edge, Rendezvous, Archive)</td>
<td>Network roles</td>
</tr>
<tr>
<td><code>icn-compute/scheduler.rs</code></td>
<td>Executor capabilities (CCL, WASM)</td>
<td>Compute roles</td>
</tr>
<tr>
<td><code>icn-store</code></td>
<td>Storage responsibilities</td>
<td>Storage roles</td>
</tr>
</tbody></table>
<p><strong>ServiceRole enum:</strong></p>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceRole {
    // Network roles (from NodeRole)
    Edge,           // Leaf node, minimal routing
    Rendezvous,     // NAT traversal helper, connection broker
    Archive,        // Long-term storage, history queries

    // Compute roles
    CclExecutor,    // Can execute CCL contracts (low requirements)
    WasmExecutor,   // Can execute WASM contracts (higher requirements)

    // Storage roles
    ReplicaHolder,  // Stores replicas for others

    // Platform roles
    Gateway,        // Runs HTTP/WebSocket gateway for apps
}
</code></pre>
<p><strong>Role combinations are common:</strong></p>
<ul>
<li><code>{Edge, CclExecutor}</code> - Typical mobile/laptop node</li>
<li><code>{Rendezvous, CclExecutor, WasmExecutor, ReplicaHolder}</code> - Beefy server</li>
<li><code>{Archive, ReplicaHolder}</code> - Cold storage node</li>
<li><code>{Gateway, CclExecutor}</code> - Application server</li>
</ul>
<hr>
<h3>13.4 NodeProfile Structure</h3>
<p><strong>NodeProfile</strong> is the unified view of a node&#39;s network participation:</p>
<pre><code class="language-rust">use std::collections::HashSet;
use icn_identity::Did;
use icn_net::TopologyInfo;
use icn_compute::NodeCapacity;

/// Complete profile describing a node&#39;s network role and capabilities
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NodeProfile {
    /// This node&#39;s DID (device identity)
    pub node_did: Did,

    /// Principal DID operating this node
    pub operator_did: Did,

    /// Network topology information (region, cluster, latency metrics)
    pub topology: TopologyInfo,

    /// Hardware capacity (CPU, RAM, storage, network)
    pub capacity: NodeCapacity,

    /// Active service roles (acquired via capability sensing)
    pub roles: HashSet&lt;ServiceRole&gt;,

    /// Current lifecycle stage
    pub stage: NodeStage,

    /// Policy constraints from operator
    pub policy: NodePolicy,

    /// Last profile update timestamp
    pub updated_at: u64,
}

/// Operator-defined constraints
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct NodePolicy {
    /// Roles this node may never acquire (even if capable)
    pub disallowed_roles: HashSet&lt;ServiceRole&gt;,

    /// Maximum resources to commit (prevent runaway usage)
    pub resource_caps: Option&lt;ResourceCaps&gt;,

    /// Cooperative memberships this node serves
    pub coop_ids: Vec&lt;String&gt;,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ResourceCaps {
    pub max_cpu_percent: u8,     // e.g., 50 = use at most 50% CPU
    pub max_ram_mb: u64,         // e.g., 4096 = cap at 4GB
    pub max_storage_mb: u64,     // e.g., 10240 = cap at 10GB
    pub max_bandwidth_mbps: u32, // e.g., 100 = cap at 100Mbps
}
</code></pre>
<p><strong>Design notes:</strong></p>
<ul>
<li><strong>Reuses existing types</strong> - <code>TopologyInfo</code> and <code>NodeCapacity</code> already exist</li>
<li><strong>Roles are a set</strong> - Additive, not exclusive categories</li>
<li><strong>Policy is negative</strong> - Disallow specific roles, don&#39;t enumerate allowed ones</li>
<li><strong>Operator DID</strong> - Links node to its principal for trust computation</li>
</ul>
<hr>
<h3>13.5 Node Lifecycle (NodeStage)</h3>
<p>Nodes progress through stages as they integrate into the network:</p>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum NodeStage {
    /// Just started, probing environment
    Sensing,

    /// Fully participating in network
    Active,

    /// Gracefully stepping down (draining tasks, transferring replicas)
    Retiring,
}
</code></pre>
<p><strong>Stage transitions:</strong></p>
<pre><code>[Sensing] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt; [Active]
    â”‚      Completed environment sensing          â”‚
    â”‚      Acquired initial roles                 â”‚
    â”‚      Connected to peers                     â”‚
    â”‚                                             â”‚
    â”‚                                             â–¼
    â”‚                              Operator initiates shutdown
    â”‚                              graceful_shutdown() called
    â”‚                                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt; [Retiring]
                                                  â”‚
                                                  â–¼
                                           Process exits
                                           (after drain complete)
</code></pre>
<p><strong>Sensing phase activities:</strong></p>
<ol>
<li>Probe hardware (CPU cores, RAM, disk, GPU)</li>
<li>Detect network (bandwidth, NAT type, latency to known peers)</li>
<li>Load operator policy (from config file)</li>
<li>Evaluate role eligibility</li>
<li>Connect to seed peers</li>
<li>Gossip initial profile</li>
</ol>
<p><strong>Active phase:</strong></p>
<ul>
<li>Participate in gossip</li>
<li>Accept tasks matching capabilities</li>
<li>Store replicas if role includes <code>ReplicaHolder</code></li>
<li>Route messages if <code>Rendezvous</code></li>
<li>Periodically re-sense (detect hardware changes)</li>
</ul>
<p><strong>Retiring phase:</strong></p>
<ul>
<li>Stop accepting new tasks</li>
<li>Complete in-flight tasks</li>
<li>Transfer replica responsibilities to other nodes</li>
<li>Gossip retirement announcement</li>
<li>Save state snapshot</li>
<li>Exit cleanly</li>
</ul>
<hr>
<h3>13.6 Role Inference</h3>
<p>Roles emerge from capability matching, not admin configuration:</p>
<pre><code class="language-rust">/// Policy for role inference (configurable thresholds)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RolePolicy {
    /// Minimum RAM to enable CCL execution (MB)
    pub ccl_min_ram_mb: u64,        // default: 128

    /// Minimum RAM to enable WASM execution (MB)
    pub wasm_min_ram_mb: u64,       // default: 512

    /// Minimum storage to enable replica holding (MB)
    pub replica_min_storage_mb: u64, // default: 1024

    /// Minimum uptime hours to enable Rendezvous role
    pub rendezvous_min_uptime_hours: u64, // default: 720 (30 days)

    /// Minimum trust score to enable Archive role
    pub archive_min_trust: f64,     // default: 0.6
}

impl NodeProfile {
    /// Infer roles from current capacity and policy
    pub fn infer_roles(&amp;mut self, policy: &amp;RolePolicy, trust_score: f64) {
        // Start fresh (re-evaluate all roles)
        self.roles.clear();

        // All nodes are at least Edge
        self.roles.insert(ServiceRole::Edge);

        // CCL executor: low bar
        if self.capacity.available.ram_mb &gt;= policy.ccl_min_ram_mb
            &amp;&amp; !self.policy.disallowed_roles.contains(&amp;ServiceRole::CclExecutor)
        {
            self.roles.insert(ServiceRole::CclExecutor);
        }

        // WASM executor: higher requirements
        if self.capacity.available.ram_mb &gt;= policy.wasm_min_ram_mb
            &amp;&amp; !self.policy.disallowed_roles.contains(&amp;ServiceRole::WasmExecutor)
        {
            self.roles.insert(ServiceRole::WasmExecutor);
        }

        // Replica holder: needs storage commitment
        if self.capacity.available.storage_mb &gt;= policy.replica_min_storage_mb
            &amp;&amp; !self.policy.disallowed_roles.contains(&amp;ServiceRole::ReplicaHolder)
        {
            self.roles.insert(ServiceRole::ReplicaHolder);
        }

        // Rendezvous: needs stable presence
        if self.uptime_hours() &gt;= policy.rendezvous_min_uptime_hours
            &amp;&amp; self.has_public_ip()
            &amp;&amp; !self.policy.disallowed_roles.contains(&amp;ServiceRole::Rendezvous)
        {
            self.roles.insert(ServiceRole::Rendezvous);
        }

        // Archive: needs high trust (community vouches for reliability)
        if trust_score &gt;= policy.archive_min_trust
            &amp;&amp; self.capacity.available.storage_mb &gt;= 10 * policy.replica_min_storage_mb
            &amp;&amp; !self.policy.disallowed_roles.contains(&amp;ServiceRole::Archive)
        {
            self.roles.insert(ServiceRole::Archive);
        }
    }
}
</code></pre>
<p><strong>Key principle:</strong> Roles are <em>acquired</em> based on capability, not <em>assigned</em> by category. A phone might acquire <code>CclExecutor</code> if it has enough RAM. A server might lack <code>Archive</code> if its trust score is low.</p>
<hr>
<h3>13.7 Multi-Device &amp; Shared Devices</h3>
<p>The NodeProfile model elegantly handles two common scenarios:</p>
<p><strong>Scenario A: One Principal, Many Nodes (Multi-Device)</strong></p>
<p>Alice uses ICN from laptop, phone, and a VPS:</p>
<pre><code>Principal: did:icn:alice
    â”‚
    â”œâ”€â”€ NodeProfile {
    â”‚       node_did: did:icn:alice-laptop,
    â”‚       operator_did: did:icn:alice,
    â”‚       roles: {Edge, CclExecutor, WasmExecutor},
    â”‚       capacity: { ram: 16GB, storage: 500GB }
    â”‚   }
    â”‚
    â”œâ”€â”€ NodeProfile {
    â”‚       node_did: did:icn:alice-phone,
    â”‚       operator_did: did:icn:alice,
    â”‚       roles: {Edge},  // Limited by policy &amp; hardware
    â”‚       capacity: { ram: 4GB, storage: 64GB }
    â”‚   }
    â”‚
    â””â”€â”€ NodeProfile {
            node_did: did:icn:alice-server,
            operator_did: did:icn:alice,
            roles: {Rendezvous, CclExecutor, WasmExecutor, ReplicaHolder},
            capacity: { ram: 32GB, storage: 1TB }
        }
</code></pre>
<p><strong>Identity layer integration:</strong> Alice&#39;s <code>DidDocument</code> (from Phase 11) lists all three devices as <code>VerificationMethod</code> entries. The NodeProfile&#39;s <code>operator_did</code> links back to the principal.</p>
<p><strong>Scenario B: One Node, Many Principals (Shared Device)</strong></p>
<p>A food coop runs a shared kiosk terminal:</p>
<pre><code>NodeProfile {
    node_did: did:icn:foodcoop-kiosk,
    operator_did: did:icn:foodcoop,  // The coop operates the kiosk
    roles: {Edge, Gateway},           // Serves app UI
    policy: {
        disallowed_roles: {WasmExecutor, ReplicaHolder}, // Security
        coop_ids: [&quot;foodcoop&quot;]  // Only serves food coop
    }
}
</code></pre>
<p>Users authenticate to the kiosk with their own DIDs, but the <em>node</em> identity is the kiosk itself. This separates:</p>
<ul>
<li><strong>Who operates the hardware</strong> (foodcoop)</li>
<li><strong>Who uses the service</strong> (members authenticating)</li>
<li><strong>What the device can do</strong> (constrained by operator policy)</li>
</ul>
<hr>
<h3>13.8 Integration with Existing Systems</h3>
<p>NodeProfile bridges three existing subsystems:</p>
<p><strong>1. Identity Layer (<code>icn-identity</code>)</strong></p>
<pre><code class="language-rust">// DidDocument has VerificationMethod per device
// NodeProfile.operator_did links to the principal&#39;s DID
// Device capabilities (in VerificationMethod) are for key permissions
// NodeProfile roles are for network participation - orthogonal concerns
</code></pre>
<p><strong>2. Network Layer (<code>icn-net</code>)</strong></p>
<pre><code class="language-rust">// TopologyInfo already exists in topology.rs
// NodeRole (Edge/Rendezvous/Archive) maps to ServiceRole
// NodeProfile.topology reuses TopologyInfo directly
// NetworkActor uses NodeProfile for routing decisions
</code></pre>
<p><strong>3. Compute Layer (<code>icn-compute</code>)</strong></p>
<pre><code class="language-rust">// NodeCapacity already exists in scheduler.rs
// ResourceProfile maps to NodeProfile.capacity
// Scheduler queries NodeProfile.roles for executor capabilities
// Trust integration via NodeProfile.operator_did â†’ trust graph lookup
</code></pre>
<p><strong>Gossip integration:</strong></p>
<pre><code class="language-rust">// New gossip topic for profile sync
const TOPIC_NODE_PROFILES: &amp;str = &quot;network:profiles&quot;;

// Message types
pub enum ProfileMessage {
    Announce(NodeProfile),  // New/updated profile
    Query(Did),             // Request profile for DID
    Response(Option&lt;NodeProfile&gt;),
}
</code></pre>
<p><strong>Profile cache in supervisor:</strong></p>
<pre><code class="language-rust">// Supervisor maintains profile cache
pub struct ProfileCache {
    profiles: HashMap&lt;Did, NodeProfile&gt;,
    updated_at: HashMap&lt;Did, u64&gt;,
}

impl ProfileCache {
    pub fn get_executors_for_task(&amp;self, task: &amp;ComputeTask) -&gt; Vec&lt;&amp;NodeProfile&gt; {
        self.profiles.values()
            .filter(|p| p.roles.contains(&amp;ServiceRole::CclExecutor))
            .filter(|p| p.stage == NodeStage::Active)
            .collect()
    }
}
</code></pre>
<hr>
<h3>13.9 Implementation Path</h3>
<p><strong>Phase 17 (Target):</strong></p>
<ol>
<li>Add <code>icn-core/src/node.rs</code> with NodeProfile, ServiceRole, NodeStage (~200 lines)</li>
<li>Wire into supervisor startup (create profile, sense environment)</li>
<li>Gossip profile to peers on <code>network:profiles</code> topic</li>
<li>Basic role inference from hardware capacity</li>
</ol>
<p><strong>Phase 18:</strong>
5. Trust integration (Archive role requires trust threshold)
6. Policy enforcement (operator constraints)
7. Scheduler integration (use NodeProfile for executor selection)</p>
<p><strong>Phase 19+:</strong>
8. Dynamic re-sensing (adapt to hardware changes)
9. Reputation tracking (nodes that perform well get better scores)
10. Load balancing (distribute based on capacity utilization)</p>
<hr>
<h2>14. Federation Layer</h2>
<p>The federation layer (<code>icn-federation</code> crate) enables multiple cooperatives to discover each other, bridge trust relationships, settle inter-cooperative credits, and coordinate via scoped gossip routing.</p>
<h3>14.1 Overview</h3>
<p>Federation addresses the challenge of <strong>inter-cooperative coordination</strong> without centralized authorities. Key capabilities:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Discovery</strong></td>
<td>Cooperatives announce presence via <code>federation:registry</code> gossip topic</td>
</tr>
<tr>
<td><strong>Trust Bridging</strong></td>
<td>Attestations from home coop travel with members to foreign coops</td>
</tr>
<tr>
<td><strong>Credit Settlement</strong></td>
<td>Bilateral clearing agreements with configurable exchange rates</td>
</tr>
<tr>
<td><strong>Scoped Gossip</strong></td>
<td>Control message routing (local, federation partners, or public)</td>
</tr>
<tr>
<td><strong>DID Resolution</strong></td>
<td>Federated DID format: <code>did:icn:coop-id:z6Mk...</code></td>
</tr>
</tbody></table>
<h3>14.2 Core Types</h3>
<p><strong>CooperativeInfo</strong> - Public identity and metadata:</p>
<pre><code class="language-rust">pub struct CooperativeInfo {
    pub coop_id: String,           // e.g., &quot;food-coop&quot;
    pub name: String,              // Human-readable name
    pub public_did: Did,           // Institutional DID
    pub gateway_endpoints: Vec&lt;String&gt;,
    pub federation_policy: FederationPolicy,
    pub currencies: Vec&lt;CurrencyInfo&gt;,
    pub capabilities: Vec&lt;String&gt;, // &quot;clearing&quot;, &quot;attestations&quot;, &quot;compute&quot;
    pub last_seen: u64,
    pub signature: Vec&lt;u8&gt;,
}
</code></pre>
<p><strong>FederationPolicy</strong> - Controls who can join:</p>
<ul>
<li><code>Open</code> - Any cooperative can federate</li>
<li><code>Vouched { min_vouches }</code> - Requires N vouches from existing partners</li>
<li><code>Closed</code> - No new federations accepted</li>
</ul>
<p><strong>GossipScope</strong> - Message routing control:</p>
<ul>
<li><code>Local</code> - Stays within cooperative</li>
<li><code>Federation { partners }</code> - Goes to specific partners</li>
<li><code>Public</code> - Broadcast to all federated cooperatives</li>
</ul>
<h3>14.3 Trust Bridging (F2)</h3>
<p><strong>FederatedTrustAttestation</strong> allows cooperatives to vouch for their members:</p>
<pre><code class="language-rust">pub struct FederatedTrustAttestation {
    pub source_coop_id: String,
    pub source_coop_did: Did,
    pub member_did: Did,
    pub trust_score: f64,          // 0.0 to 1.0
    pub trust_context: TrustContext, // Economic, Social, Governance, General
    pub evidence_summary: Vec&lt;EvidenceSummary&gt;,
    pub issued_at: u64,
    pub expires_at: u64,
    pub signature: Vec&lt;u8&gt;,
}
</code></pre>
<p>Foreign cooperatives can request attestations about visiting members, enabling trust to travel across federation boundaries.</p>
<h3>14.4 Credit Settlement (F3)</h3>
<p><strong>BilateralClearingAgreement</strong> defines exchange terms between two cooperatives:</p>
<pre><code class="language-rust">pub struct BilateralClearingAgreement {
    pub agreement_id: String,
    pub coop_a: String,
    pub coop_a_did: Did,
    pub coop_b: String,
    pub coop_b_did: Did,
    pub exchange_rates: HashMap&lt;String, f64&gt;, // &quot;hours:USD&quot; -&gt; 25.0
    pub settlement_interval: SettlementInterval,
    pub max_imbalance: i64,
    pub signatures: Vec&lt;(Did, Vec&lt;u8&gt;)&gt;,
}
</code></pre>
<p><strong>CrossCoopTransfer</strong> tracks inter-cooperative payments through the clearing system.</p>
<h3>14.5 Federated DID Resolution (F5)</h3>
<p>DIDs can optionally include a cooperative prefix for cross-federation resolution:</p>
<table>
<thead>
<tr>
<th>Format</th>
<th>Example</th>
<th>Resolution</th>
</tr>
</thead>
<tbody><tr>
<td>Standard</td>
<td><code>did:icn:z6Mk...</code></td>
<td>Local resolution</td>
</tr>
<tr>
<td>Federated</td>
<td><code>did:icn:food-coop:z6Mk...</code></td>
<td>Route to food-coop&#39;s gateway</td>
</tr>
</tbody></table>
<p>The <strong>FederatedDidResolver</strong> caches resolutions and queries remote gateways when needed.</p>
<h3>14.6 Gossip Topics</h3>
<table>
<thead>
<tr>
<th>Topic</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>federation:registry</code></td>
<td>Cooperative announcements, queries, vouches</td>
</tr>
<tr>
<td><code>federation:trust</code></td>
<td>Trust attestation exchange</td>
</tr>
<tr>
<td><code>federation:clearing</code></td>
<td>Settlement coordination</td>
</tr>
</tbody></table>
<h3>14.7 Architecture</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Federation Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   Registry   â”‚  â”‚  Attestation â”‚  â”‚   Clearing   â”‚       â”‚
â”‚  â”‚              â”‚  â”‚    Store     â”‚  â”‚   Manager    â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                 â”‚                 â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚              FederationGossipHandler             â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                           â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚           FederatedGossipRouter                  â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚       â”‚
â”‚  â”‚  â”‚Channel Aâ”‚  â”‚Channel Bâ”‚  â”‚Channel Câ”‚          â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                           â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚            FederatedDidResolver                  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ icn-gossip    â”‚
                    â”‚ icn-store     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>14.8 Metrics</h3>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>icn_federation_coops_known</code></td>
<td>Gauge</td>
<td>Known cooperatives</td>
</tr>
<tr>
<td><code>icn_federation_coops_registered</code></td>
<td>Counter</td>
<td>New registrations</td>
</tr>
<tr>
<td><code>icn_federation_announcements_sent</code></td>
<td>Counter</td>
<td>Announcements broadcast</td>
</tr>
<tr>
<td><code>icn_federation_vouches_received</code></td>
<td>Counter</td>
<td>Vouches received (by voucher)</td>
</tr>
<tr>
<td><code>icn_federation_attestations_stored</code></td>
<td>Counter</td>
<td>Attestations stored</td>
</tr>
<tr>
<td><code>icn_federation_channels_active</code></td>
<td>Gauge</td>
<td>Active federation channels</td>
</tr>
<tr>
<td><code>icn_federation_clearing_agreements_active</code></td>
<td>Gauge</td>
<td>Active clearing agreements</td>
</tr>
<tr>
<td><code>icn_federation_transfers_confirmed</code></td>
<td>Counter</td>
<td>Transfers confirmed</td>
</tr>
<tr>
<td><code>icn_federation_did_cache_hits</code></td>
<td>Counter</td>
<td>DID resolution cache hits</td>
</tr>
</tbody></table>
<h3>14.9 Implementation Status</h3>
<p><strong>Complete (F1-F5 + Daemon Integration):</strong></p>
<ul>
<li>âœ… Types and error handling</li>
<li>âœ… Cooperative registry with persistence</li>
<li>âœ… Federation gossip handler</li>
<li>âœ… Trust attestation storage</li>
<li>âœ… Bilateral clearing agreements</li>
<li>âœ… Scoped gossip routing</li>
<li>âœ… Federated DID resolution</li>
<li>âœ… <strong>Supervisor integration</strong> (2025-11-28)<ul>
<li>FederationGossipHandler wired into supervisor</li>
<li>Gossip-based send callback for publishing</li>
<li>Federation topic subscriptions (registry, trust, clearing)</li>
<li>Notification callback routing for incoming messages</li>
<li>Periodic announcement task (5-minute interval)</li>
<li>FederationConfig with coop_id/coop_name fields</li>
</ul>
</li>
<li>âœ… 47 tests passing</li>
</ul>
<p><strong>Pending:</strong></p>
<ul>
<li>â³ CLI commands (<code>icnctl federation</code>)</li>
<li>â³ Gateway REST API (<code>/v1/federation/*</code>)</li>
</ul>
<hr>
<h2>Appendix</h2>
<h3>A. Phase Numbering</h3>
<p><strong>Note:</strong> Phase references throughout this document (e.g., Phase 7, Phase 16A-E) correspond to milestones in the internal ICN development roadmap. These numbers are preserved for traceability between this architectural specification and the project&#39;s implementation history.</p>
<ul>
<li><strong>Early phases (7-9):</strong> Core substrate delivery (identity, transport, gossip)</li>
<li><strong>Phase 11-14:</strong> Platform layer (multi-device, economic safety, governance, gateway API)</li>
<li><strong>Phase 15-16:</strong> Distributed compute layer evolution</li>
</ul>
<p>Phase numbers remain in-place to anchor architectural decisions to specific implementation commits and to provide context for design rationale.</p>
<hr>
<h3>B. Glossary</h3>
<ul>
<li><strong>DID:</strong> Decentralized Identifier</li>
<li><strong>CCL:</strong> Cooperative Contract Language</li>
<li><strong>DAG:</strong> Directed Acyclic Graph</li>
<li><strong>NAT:</strong> Network Address Translation</li>
<li><strong>TLS:</strong> Transport Layer Security</li>
<li><strong>QUIC:</strong> Quick UDP Internet Connections</li>
<li><strong>HSM:</strong> Hardware Security Module</li>
</ul>
<h3>C. References</h3>
<ul>
<li><strong>DIDs:</strong> <a href="https://www.w3.org/TR/did-core/" target="_blank" rel="noopener">https://www.w3.org/TR/did-core/</a></li>
<li><strong>Ed25519:</strong> <a href="https://ed25519.cr.yp.to/" target="_blank" rel="noopener">https://ed25519.cr.yp.to/</a></li>
<li><strong>QUIC:</strong> <a href="https://datatracker.ietf.org/doc/html/rfc9000" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc9000</a></li>
<li><strong>Age encryption:</strong> <a href="https://age-encryption.org/" target="_blank" rel="noopener">https://age-encryption.org/</a></li>
<li><strong>Mutual credit:</strong> <a href="https://www.mutual-credit.org/" target="_blank" rel="noopener">https://www.mutual-credit.org/</a></li>
</ul>
<h3>D. Decision Log</h3>
<table>
<thead>
<tr>
<th>Date</th>
<th>Decision</th>
<th>Rationale</th>
</tr>
</thead>
<tbody><tr>
<td>2025-11-10</td>
<td>Tokio runtime</td>
<td>Ecosystem maturity</td>
</tr>
<tr>
<td>2025-11-10</td>
<td>Ed25519 keys</td>
<td>Standard, audited</td>
</tr>
<tr>
<td>2025-11-10</td>
<td>QUIC transport</td>
<td>Modern, multiplexed</td>
</tr>
<tr>
<td>2025-11-10</td>
<td>Double-entry ledger</td>
<td>Cooperative finance model</td>
</tr>
<tr>
<td>2025-11-10</td>
<td>Trust-gated everything</td>
<td>Security through relationships</td>
</tr>
</tbody></table>
<h3>E. Versioning Policy</h3>
<p><strong>Semantic Versioning:</strong></p>
<ul>
<li><strong>Major version:</strong> Breaking changes to core protocol or wire format (e.g., 1.x â†’ 2.0)</li>
<li><strong>Minor version:</strong> New capabilities, optional fields, non-breaking extensions (e.g., 1.0 â†’ 1.1)</li>
<li><strong>Patch version:</strong> Bugfixes, clarifications, documentation improvements (e.g., 1.0.0 â†’ 1.0.1)</li>
</ul>
<p><strong>Protocol Compatibility:</strong></p>
<p>ICN nodes negotiate protocol versions during handshake. Old nodes can communicate with new nodes within the same major version. Major version bumps require coordinated network upgrades.</p>
<h3>F. Contributions</h3>
<p><strong>Development:</strong></p>
<p>Contributions via GitHub pull requests are welcome. Major design changes require an ICN Design Proposal (ICN-DEP) for community review before implementation.</p>
<p><strong>Security Disclosures:</strong></p>
<p>Security vulnerabilities should be reported via the encrypted contact in Section 8.3 (Incident Response). Public disclosure only after fixes are deployed.</p>
<hr>
<p><strong>Document status:</strong> Living - expect updates as we implement and learn.</p>
</article> <!-- Footer nav --> <div class="doc-footer" data-astro-cid-uadgga6g> <a href="/docs" class="btn btn-ghost" data-astro-cid-uadgga6g>â† Back to Docs</a> </div> </div> </section>  </main> <!-- Footer --> <footer class="footer"> <div class="container"> <div class="footer-inner"> <div class="footer-brand"> <a href="/" class="nav-logo"> <svg class="nav-logo-svg" width="28" height="28" viewBox="0 0 128 128" fill="none"> <rect width="128" height="128" rx="28" fill="url(#ft-bg)"></rect> <line x1="64" y1="30" x2="34" y2="82" stroke="url(#ft-teal)" stroke-width="4" stroke-linecap="round" opacity="0.6"></line> <line x1="64" y1="30" x2="94" y2="82" stroke="url(#ft-teal)" stroke-width="4" stroke-linecap="round" opacity="0.6"></line> <line x1="34" y1="82" x2="94" y2="82" stroke="url(#ft-teal)" stroke-width="4" stroke-linecap="round" opacity="0.6"></line> <circle cx="64" cy="30" r="11" fill="url(#ft-teal)"></circle> <circle cx="34" cy="82" r="11" fill="url(#ft-teal)"></circle> <circle cx="94" cy="82" r="11" fill="url(#ft-teal)"></circle> <circle cx="64" cy="64" r="4" fill="url(#ft-teal)" opacity="0.8"></circle> <defs> <linearGradient id="ft-bg" x1="0" y1="0" x2="1" y2="1"><stop stop-color="#0f2027"></stop><stop offset="1" stop-color="#0a1628"></stop></linearGradient> <linearGradient id="ft-teal" x1="0" y1="0" x2="1" y2="1"><stop stop-color="#2dd4bf"></stop><stop offset="1" stop-color="#38bdf8"></stop></linearGradient> </defs> </svg> <span>InterCooperative Network</span> </a> <p>A substrate daemon for the cooperative internet. Infrastructure for cooperatives, communities, and federations.</p> </div> <div class="footer-col"> <h4>Project</h4> <ul> <li><a href="/about">About</a></li> <li><a href="/docs">Documentation</a></li> <li><a href="/architecture">Architecture</a></li> <li><a href="/roadmap">Roadmap</a></li> </ul> </div> <div class="footer-col"> <h4>Resources</h4> <ul> <li><a href="/docs/GETTING_STARTED">Getting Started</a></li> <li><a href="/docs/glossary">Glossary</a></li> <li><a href="/docs/CONTRIBUTING">Contributing</a></li> <li><a href="https://github.com/InterCooperative-Network/icn/discussions" target="_blank">Discussions</a></li> </ul> </div> <div class="footer-col"> <h4>Community</h4> <ul> <li><a href="https://github.com/InterCooperative-Network/icn" target="_blank">GitHub</a></li> <li><a href="https://github.com/InterCooperative-Network/icn/issues" target="_blank">Issues</a></li> <li><a href="/community">Community</a></li> </ul> </div> </div> <div class="footer-bottom"> <span>AGPL-3.0 License Â· InterCooperative Network</span> <span>Built with cooperation, not extraction</span> </div> </div> </footer> <script>
    // Mobile nav toggle
    document.getElementById('nav-toggle')?.addEventListener('click', () => {
      document.getElementById('nav-links')?.classList.toggle('open');
    });

    // Scroll-reveal animations
    const revealObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('revealed');
          revealObserver.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });

    document.querySelectorAll('.card, .section-header, .arch-box, .stage-item, .docs-section-card, .primitive').forEach(el => {
      el.classList.add('reveal');
      revealObserver.observe(el);
    });
  </script> </body> </html> 